[
  {
    "objectID": "stock-gbm.html",
    "href": "stock-gbm.html",
    "title": "Simulating Stock Price Path with GBM",
    "section": "",
    "text": "The Geometric Brownian Motion (GBM) model is widely used to model stock prices. It assumes that the stock price \\(S_t\\) follows the stochastic differential equation (SDE): \\[\ndS_t = \\mu S_t dt + \\sigma S_t dW_t,\n\\tag{1}\\]\nor, equivalently, \\[\n\\frac{dS_t}{S_t} = \\mu dt + \\sigma dW_t\n\\] where:\n\n\\(\\mu\\) is the drift coefficient: the expected rate of return of the stock (as \\(dS_t / S_t\\) can be viewed as the instantaneous return).\n\\(\\sigma\\) is the volatility coefficient: the standard deviation of returns.\n\\(W_t\\) is a standard Brownian motion (Wiener process).\n\nApplying Itô’s lemma, we can derive the process followed by the logarithm of the stock price: \\[\nd(\\ln S_t) = \\left(\\mu - \\frac{\\sigma^2}{2}\\right) dt + \\sigma dW_t.\n\\tag{2}\\]\nAs we will see in the next sections, we can simulate stock price paths using two different approaches based on these two equations."
  },
  {
    "objectID": "stock-gbm.html#recap-gbm-model-for-stock-prices",
    "href": "stock-gbm.html#recap-gbm-model-for-stock-prices",
    "title": "Simulating Stock Price Path with GBM",
    "section": "",
    "text": "The Geometric Brownian Motion (GBM) model is widely used to model stock prices. It assumes that the stock price \\(S_t\\) follows the stochastic differential equation (SDE): \\[\ndS_t = \\mu S_t dt + \\sigma S_t dW_t,\n\\tag{1}\\]\nor, equivalently, \\[\n\\frac{dS_t}{S_t} = \\mu dt + \\sigma dW_t\n\\] where:\n\n\\(\\mu\\) is the drift coefficient: the expected rate of return of the stock (as \\(dS_t / S_t\\) can be viewed as the instantaneous return).\n\\(\\sigma\\) is the volatility coefficient: the standard deviation of returns.\n\\(W_t\\) is a standard Brownian motion (Wiener process).\n\nApplying Itô’s lemma, we can derive the process followed by the logarithm of the stock price: \\[\nd(\\ln S_t) = \\left(\\mu - \\frac{\\sigma^2}{2}\\right) dt + \\sigma dW_t.\n\\tag{2}\\]\nAs we will see in the next sections, we can simulate stock price paths using two different approaches based on these two equations."
  },
  {
    "objectID": "stock-gbm.html#approach-1-direct-simulation-of-stock-prices",
    "href": "stock-gbm.html#approach-1-direct-simulation-of-stock-prices",
    "title": "Simulating Stock Price Path with GBM",
    "section": "Approach 1: Direct Simulation of Stock Prices",
    "text": "Approach 1: Direct Simulation of Stock Prices\nEquation 1 can be discretized over small time intervals \\(\\Delta t\\) as: \\[\nS_{t+\\Delta t} - S_t = \\mu S_t \\Delta t + \\sigma S_t \\epsilon \\sqrt{\\Delta t},\n\\] where \\(\\epsilon \\sim N(0,1)\\) is a standard normal random variable. The discretization replaces the infinitesimal change \\(dS_t\\) with a finite difference \\(S_{t+\\Delta t} - S_t\\), and \\(dW_t\\) with \\(\\epsilon \\sqrt{\\Delta t}\\).\nTwo points to note:\n\nThe term \\(\\epsilon \\sqrt{\\Delta t}\\) follows from the property of Brownian motion increments, which are normally distributed with mean 0 and variance \\(\\Delta t\\). This is true even the time interval \\(\\Delta t\\) is large.\nThis discretization is an approximation of price change over a short period of time \\(\\Delta t\\) because it assumes that \\(S_t\\) does not change significantly over the interval \\(\\Delta t\\).1 Therefore, the smaller the \\(\\Delta t\\), the more accurate the approximation.\n\n1 The SDE given by Equation 1 can be viewed as an Itô process\n\\[\ndx = a(x,t) dt + b(x,t) dW_t,\n\\]\nwhere both the expected drift rate and variance of \\(x\\) depend on the current value \\(x\\), and change over time. Our discretization assumes that over a small time interval \\(\\Delta t\\), the coefficients \\(a(x,t)\\) and \\(b(x,t)\\) remain approximately constant, allowing us to use their values at the beginning of the interval. This is known as the Euler-Maruyama method for numerically solving SDEs.This discretization leads us to simulate the stock price path by iteratively applying the above equation starting from an initial price \\(S_0\\).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Parameters\nS0 = 100  # Initial stock price\nmu = 0.05  # Drift coefficient\nsigma = 0.2  # Volatility coefficient\nT = 1.0  # Time horizon (1 year)\nN = 252  # Number of time steps (trading days in a year)\ndt = T / N  # Time step size\n\n# Generate all the standard normal shocks at once\nepsilon = np.random.normal(loc=0, scale=1, size=N)\n\n# Initialize the stock price array\n# We need N+1 points to include S0\nS = np.zeros(N+1)\n\n# set the initial stock price\nS[0] = S0\n\n# Simulate stock price path\nfor t in range(1, N+1):\n    S[t] = S[t-1] * (1 + mu * dt + sigma * epsilon[t-1] * np.sqrt(dt))\n\n# Plot the stock price path\nfig, ax = plt.subplots()\nax.plot(np.linspace(0, T, num=N+1), S)\nax.set_title('Simulated Stock Price Path using Direct Simulation of Prices')\nax.set_xlabel('Time (years)')\nax.set_ylabel('Stock Price')\nax.grid(axis='y', linestyle='--')\nplt.show()\n\n# Print the first and last 3 days of the simulated stock prices\nprint(\"First 3 days:\", S[:4]) # S[0] is the initial price\nprint(\"Last 3 days:\", S[-3:])\n\n\n\n\n\n\n\n\nFirst 3 days: [100.         100.64564228 100.49029032 101.33024055]\nLast 3 days: [102.38521068 100.77907013 101.96447248]"
  },
  {
    "objectID": "stock-gbm.html#approach-2-simulation-via-log-prices",
    "href": "stock-gbm.html#approach-2-simulation-via-log-prices",
    "title": "Simulating Stock Price Path with GBM",
    "section": "Approach 2: Simulation via Log-Prices",
    "text": "Approach 2: Simulation via Log-Prices\nWe can also simulate stock prices by first simulating the logarithm of stock prices using Equation 2, and then exponentiating to get the stock prices.\nThe SDE of \\(\\ln S_t\\) given by Equation 2 implies that for any time interval \\(\\Delta t\\),\n\\[\n\\ln S_{t+\\Delta t} - \\ln S_t = \\left(\\mu - \\frac{\\sigma^2}{2}\\right) \\Delta t + \\sigma \\epsilon \\sqrt{\\Delta t}.\n\\tag{3}\\]\nThis result does not involve any approximation as both the drift and variance terms of the \\(ln S_t\\) process are constant.2\n2 The SDE for \\(\\ln S_t\\) is a generalized Wiener process,\n\\[\ndx = a\\, dt + b\\, dW_t,\n\\]\nwhere both \\(a\\) and \\(b\\) are constants. This allows us to directly write down the distribution of increments over any time interval \\(\\Delta t\\) without approximation.3 Since equation Equation 3 holds for all \\(\\Delta t \\geq 0,\\) it’s tempting to simulate a stock price path with time interval \\(\\Delta t\\) by first constructing a sequence of \\(\\{\\epsilon \\sqrt{\\Delta t}, \\epsilon \\sqrt{2 \\Delta t}, ...\\}\\), where each \\(\\epsilon\\) is independently drawn from \\(N(0, 1)\\), and then using this sequence to build the log-price path. However, this approach is flawed because the increments of Brownian motion over overlapping intervals are not independent. For example, the increment \\(W_{2\\Delta t} - W_0\\) shares the same underlying Brownian motion as \\(W_{\\Delta t} - W_0\\). Therefore, we cannot simply generate independent normal variables for overlapping increments.We can simulate the log-price path by iteratively applying the above equation starting from an initial log-price \\(\\ln S_0\\). Once we have the log-prices, we can exponentiate them to get the stock prices.3\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Parameters\nS0 = 100  # Initial stock price\nmu = 0.05  # Drift coefficient\nsigma = 0.2  # Volatility coefficient\nT = 1.0  # Time horizon (1 year)\nN = 252  # Number of time steps (trading days in a year)\ndt = T / N  # Time step size\n\n# Generate all the standard normal shocks at once\nepsilon = np.random.normal(loc=0, scale=1, size=N)\n\n# Initialize the stock price and log stock price arrays\n# We need N+1 points to include S0\nS = np.zeros(N+1)\nlog_S = np.zeros(N+1)\n\n# Set the initial log stock price\nlog_S[0] = np.log(S0)\n\n# Simulate stock price path\nfor t in range(1, N+1):\n    log_S[t] = log_S[t-1] + (mu - 0.5 * sigma**2) * dt + sigma * epsilon[t-1] * np.sqrt(dt)\n\n# Exponentiate to get stock prices\nS = np.exp(log_S)\n\n# Plot the stock price path\nfig, ax = plt.subplots()\nax.plot(np.linspace(0, T, num=N+1), S)\nax.set_title('Simulated Stock Price Path using Log-Price Simulation')\nax.set_xlabel('Time (years)')\nax.set_ylabel('Stock Price')\nax.grid(axis='y', linestyle='--')\nplt.show()\n\n# Print the first and last 3 days of the simulated stock prices\nprint(\"First 3 days:\", S[:4]) # S[0] is the initial price\nprint(\"Last 3 days:\", S[-3:])\n\n\n\n\n\n\n\n\nFirst 3 days: [100.         100.63974344 100.47654577 101.31185987]\nLast 3 days: [102.23771695 100.63841696 101.82107276]\n\n\nNote that the stock price paths generated by both approaches are almost identical, as they are based on the same underlying GBM model and we have set the random seed for reproducibility. However, the log-price simulation is generally more accurate and stable, especially for larger time steps, because it avoids the approximation error inherent in the direct price simulation."
  },
  {
    "objectID": "stock-gbm.html#a-more-efficient-implementation",
    "href": "stock-gbm.html#a-more-efficient-implementation",
    "title": "Simulating Stock Price Path with GBM",
    "section": "A More Efficient Implementation",
    "text": "A More Efficient Implementation\nTaking the simulation via log-price approach, we can improve its efficiency by taking advantage of vectorized operations in NumPy. Instead of simulating each time step in a loop, we can calculate all time steps at once.\nTo do so, we first generate the Brownian motion path by cumulatively summing the scaled normal shocks (np.cumsum()). We then compute the log-prices using vectorized operations, and finally exponentiate to get the stock prices.\nLet’s write a function that implements this more efficient approach. In addition to the parameters used in the previous examples, the function takes another parameter specifying the number of paths to simulate. (We also include an optional random seed parameter for reproducibility.)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef simulate_gbm_path(S0, mu, sigma, T, N, num_path, seed=None):\n\n    if seed is not None:\n        np.random.seed(seed)\n    \n    dt = T / N # Time step size\n    t = np.linspace(0, T, N+1) # Time grid; N+1 points to include t=0\n\n    # Generate all the standard normal shocks at once for all paths\n    eps = np.random.normal(size=(num_path, N))\n    \n    # Generate the Brownian motion paths; add W(0) = 0\n    W = np.cumsum(np.sqrt(dt) * eps, axis=1)\n    W = np.concatenate((np.zeros((num_path, 1)), W), axis=1)\n\n    # Calculate log-prices using vectorized operations\n    log_S = np.log(S0) + (mu - 0.5 * sigma**2) * t + sigma * W\n\n    # Exponentiate to get stock prices\n    return np.exp(log_S)\n\n\nnp.sqrt(dt) * epsilon is an array of size (num_path, N). np.cumsum(, axis=1) cumulatively sum over all columns (axis=1) for each row of paths. This gives us the Brownian motion paths. (See here for more on np.cumsum().)\nconcatenates a column of zeros at the beginning of the Brownian motion paths to represent \\(W(0) = 0\\) for all paths. (See here for more on np.concatenate().)\n\nNow, let’s use this function to simulate and plot multiple stock price paths.\n\n# Parameters\nS0 = 100  # Initial stock price\nmu = 0.05  # Drift coefficient\nsigma = 0.2  # Volatility coefficient\nT = 1.0  # Time horizon (1 year)\nN = 252  # Number of time steps (trading days in a year)\nnum_path = 3  # Number of paths to simulate\n\n# Simulate stock price paths\nS = simulate_gbm_path(S0, mu, sigma, T, N, num_path, seed=42)\n\n# Plot the stock price path\nfig, ax = plt.subplots()\n\n# Plot each row as a separate line\nt = np.linspace(0, T, num=N+1)\nfor i in range(num_path):\n    ax.plot(t, S[i], label=f'Path {i+1}')\n\nax.set_title('Simulated Stock Price Path using Log-Price Simulation')\nax.set_xlabel('Time (years)')\nax.set_ylabel('Stock Price')\nax.grid(axis='y', linestyle='--')\nplt.legend()\nplt.show()\n\n# Print the first and last 3 days of the simulated stock prices for the first path\nprint(\"First 3 days of Path 1:\", S[0, :4]) # S[0,0] is the initial price\nprint(\"Last 3 days of Path 1:\", S[0, -3:])\n\n\n\n\n\n\n\n\nFirst 3 days of Path 1: [100.         100.63974344 100.47654577 101.31185987]\nLast 3 days of Path 1: [102.23771695 100.63841696 101.82107276]\n\n\nNote that the output for stock price path 1 is identical to those generated by the previous log-price simulation approach as both simulations are based on the exact same algorithm and we have set the random seed for reproducibility.\nThis implementation is more efficient because it leverages NumPy’s ability to perform operations on entire arrays at once, rather than iterating through each time step and path individually. This can lead to significant performance improvements, especially when simulating a large number of paths or time steps."
  },
  {
    "objectID": "stock-gbm.html#references",
    "href": "stock-gbm.html#references",
    "title": "Simulating Stock Price Path with GBM",
    "section": "References",
    "text": "References\nHull, J. C. (2021). Options, Futures, and Other Derivatives (11th ed.). Pearson."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Finance with Python - A Few Examples",
    "section": "",
    "text": "Simulating Stock Price Path with GBM\nPricing Options with a Binomial Tree\nDelta Hedging a European Call Option"
  },
  {
    "objectID": "delta-hedging.html",
    "href": "delta-hedging.html",
    "title": "Delta Hedging a European Call Option",
    "section": "",
    "text": "Delta hedging is a fundamental strategy in options trading that aims to reduce the directional risk associated with price fluctuations in the underlying asset. By dynamically adjusting their holdings in the underlying asset, traders can maintain a delta-neutral portfolio, thereby mitigating potential losses from price movements.\nIn this tutorial, we demonstrate how to implement a delta hedging strategy for a European call option using Python. We simulate the underlying stock price using Geometric Brownian Motion (GBM), compute the option’s delta via the Black–Scholes model, and periodically adjust the hedge at a specified rebalancing frequency."
  },
  {
    "objectID": "delta-hedging.html#introduction",
    "href": "delta-hedging.html#introduction",
    "title": "Delta Hedging a European Call Option",
    "section": "",
    "text": "Delta hedging is a fundamental strategy in options trading that aims to reduce the directional risk associated with price fluctuations in the underlying asset. By dynamically adjusting their holdings in the underlying asset, traders can maintain a delta-neutral portfolio, thereby mitigating potential losses from price movements.\nIn this tutorial, we demonstrate how to implement a delta hedging strategy for a European call option using Python. We simulate the underlying stock price using Geometric Brownian Motion (GBM), compute the option’s delta via the Black–Scholes model, and periodically adjust the hedge at a specified rebalancing frequency."
  },
  {
    "objectID": "delta-hedging.html#recap-of-key-concepts",
    "href": "delta-hedging.html#recap-of-key-concepts",
    "title": "Delta Hedging a European Call Option",
    "section": "Recap of Key Concepts",
    "text": "Recap of Key Concepts\nBefore we get into the implementation, let’s briefly revisit some key concepts behind delta hedging.\n\nDelta and BS Delta\nThe Delta (\\(\\Delta\\)) of an option measures the sensitivity of an option’s price to changes in the price of the underlying asset. For a call option, delta ranges from 0 to 1, indicating how much the option price is expected to change for a small change in the underlying asset’s price. For example, a delta of 0.6 means that for a small increase in the underlying asset’s price, the option price is expected to increase by approximately 60% of that change.\nThe Black-Scholes model is a mathematical model used to price European options and calculate their Greeks, including delta. Under the Black-Scholes framework, the price of a European call option (on a non-dividend-paying stock) with stock price \\(S\\), strike price \\(K\\), time to expiration \\(T\\), risk-free interest rate \\(r\\), and volatility \\(\\sigma\\) is given by:\n\\[C(S, K, T, r, \\sigma) = S N(d_1) - K e^{-rT} N(d_2),\\]\nwhere \\[d_1 = \\frac{\\ln(S / K) + (r + \\sigma^2 / 2) T}{\\sigma \\sqrt{T}},\\] \\[d_2 = d_1 - \\sigma \\sqrt{T},\\] and \\(N(\\cdot)\\) is the cumulative distribution function of the standard normal distribution.\nThe Black-Scholes delta (BS delta) of a European call option can be calculated as follows:\n\\[\\Delta(\\text{Call}) = \\frac{\\partial C}{\\partial S} = N(d_1)\\]\nNote that at expiration (\\(T=0\\)), the delta of a call option is \\(1\\) if the option is in-the-money (\\(S &gt; K\\)) and \\(0\\) if it is out-of-the-money (\\(S \\leq K\\)).\n\n\nDelta Hedging\nThe Delta hedging strategy involves taking a position in the underlying asset that offsets the delta of the option position.\nFor example, if you sold a call option on \\(100\\) shares of a stock and the option’s BS delta is \\(0.6\\), you would buy \\(0.6 \\times 100 = 60\\) shares of the stock to hedge your position. This hedge operation is known as delta neutralization. A short position in a call option with 100 shares means the total delta on the option is \\(0.6 \\times (-100) = -600.\\) The delta of one share of a stock is \\(1\\), so by buying \\(600\\) shares of the stock, you neutralize the delta of the option position. Since delta changes as the underlying asset price changes, to keep a delta neutral position, the hedge must be adjusted continuously.\nFormally, to hedge a short position in a call option (with a standard contract size of 100 shares of the underlying stock), you hold \\(100\\Delta\\) units of the underlying stock.1 Therefore, the value of your hedging portfolio at time \\(t\\) is:\n1 Conversely, to hedge a long position in a call option, you hold \\(-100\\Delta\\) units of the underlying stock.\\[\nV_t^{\\text{hedge}} = 100 \\Delta_t S_t + B_t,\n\\]\nwhere \\(100 \\Delta_t S_t\\) is the value of the stock position, and \\(B_t\\) is the value of the cash or bond position. A negative \\(B_t\\) indicates a borrowing position.\nDefine\n\\[\nB_0 = V_0^{\\text{opt}} - 100\\Delta_0 S_0,\n\\tag{1}\\]\nwhere \\(V_0^{\\text{opt}}\\) is the initial option value at time \\(0\\), which is the option price calculated using the Black-Scholes formula, and \\(100\\Delta_0 S_0\\) is the cost of purchasing the initial hedge position in the underlying stock. In this setup, we assume the option is sold at time \\(0\\) at its theoretical price, and the premium received from selling the option is included in the initial cash position \\(B_0\\).\nFurther, suppose that we re-balance at \\(\\Delta t\\) intervals. The cash position \\(B_t\\) then evolves over time as follows: \\[\nB_t = B_{t-1}e^{r\\Delta t} - 100(\\Delta_t - \\Delta_{t-1})S_t,\n\\tag{2}\\] where \\(r\\) is the risk-free interest rate. The first term on the right-hand side represents the growth of the cash position due to interest, while the second term represents the cost (or proceeds) from adjusting the stock position to maintain delta neutrality.\nIf the hedge is perfect (i.e., \\(\\Delta t \\to 0\\)), this portfolio replicates the option’s price path: \\[\nV_t^{\\text{hedge}} = V_t^{\\text{opt}}\n\\] for all \\(t\\).\nFor discrete rebalancing, there are replication errors. In particular, at expiration \\(T\\), the replication error is given by: \\[\n\\begin{align*}\n    \\varepsilon_T &= V_T^{\\text{hedge}} - V_T^{\\text{opt}} \\\\\n    &= 100 \\Delta_T S_T + B_T - 100\\max(S_T - K, 0) \\\\\n    &= \\begin{cases}\n            B_T + K  & \\text{if } S_T &gt; K \\\\\n            B_T      & \\text{if } S_T \\leq K\n        \\end{cases}\n\\end{align*}\n\\tag{3}\\]\nAgain, if the hedge is perfect, then \\(\\varepsilon_T = 0\\), but with discrete rebalancing, \\(\\varepsilon_T\\) will generally be non-zero and can be positive (a profit) or negative (a loss). The expected value of \\(\\varepsilon_T\\) is typically negative, reflecting the cost of hedging.2\n2 If the model is mis-specified (e.g., the true volatility is lower than the assumed volatility), the expected replication error can be positive.One commonly used metric to measure hedging performance is the ratio of the standard deviation of the replication error \\(\\varepsilon_T\\) (discounted to \\(t=0\\)) to the option’s theoretical price \\(V_0^{\\text{opt}}\\). Define \\(\\tilde{\\varepsilon}_T := e^{-rT} \\varepsilon_T.\\) The hedging performance is then given by: \\[\n\\frac{\\text{sd}(\\tilde{\\varepsilon}_T)}{V_0^{\\text{opt}}}\n\\]\nThis measure scales the disperse of replication error by the option price, providing a normalized measure of hedging effectiveness. It allows meaningful comparison of hedge performance across options with different strikes, maturities, volatilities, or underlyings with different price levels.3\n3 Note that to measure hedging performance, we care about the dispersion of the replication error, not its expected value. The dispersion captures how much residual risk (unhedged randomness) remains after hedging. On the other hand, the expected value of the replication error captures systematic bias of hedging (i.e., on average over/under hedging).\n\nAn Alternative Formulation\nThe above formulation of delta hedging start by setting up a hedging portfolio that replicates the option’s price at \\(t=0\\). That is, the initial cash position \\(B_0\\) includes the premium received from selling the option (see Equation 1) so that the total value of the hedging portfolio equals the option price at \\(t=0\\).\nAn alternative approach is to start with \\[\nB_0 = - 100\\Delta_0 S_0\n\\]\nThe initial value of the hedging portfolio is now zero, i.e., \\(V_0^{\\text{hedge}} = 0.\\)\nThe evolution of \\(B_t\\) is still given by Equation 2. The negative of the cash position (i.e., \\(-B_t\\)) now represents the cumulative cost of hedging up to time \\(t\\) (excluding the initial option premium received).\nIf the hedging is perfect, \\(V_t^{\\text{hedge}} = 0\\) for all \\(t\\), but this is of course not possible with discrete rebalancing.\nAt expiration, the replication error at expiration is again given by Equation 3. However, the interpretation of the replication error is now different. The replication error (\\(-\\varepsilon_T\\), to be more precise) now captures the total cost of hedging, excluding the initial option premium received.\nUnder perfect hedging, the replication error (again \\(-\\varepsilon_T\\) to be precise) is equal to the option payoff (i.e., the total cost of hedging equals the option payoff). This also means that the expected value of the replication error (\\(-E[\\varepsilon_T]\\)) discounted to \\(t=0\\) is equal to the theoretical price of the option.\nWith discrete rebalancing, the replication error (\\(-\\varepsilon_T\\)) will generally be different from the option payoff. The expected value of the replication error (\\(-E[\\varepsilon_T]\\)) discounted to \\(t=0\\) is typically more than the theoretical price of the option, reflecting the cost of hedging."
  },
  {
    "objectID": "delta-hedging.html#scenario-setup",
    "href": "delta-hedging.html#scenario-setup",
    "title": "Delta Hedging a European Call Option",
    "section": "Scenario Setup",
    "text": "Scenario Setup\nWe use the same setup as in Hull (2021) (chapter 19) to illustrate the delta hedging strategy. We assume a financial institution has sold a European call option on \\(100,000\\) shares of a non-dividend-paying stock and wants to hedge its position using delta hedging. The institution will adjust its hedge position weekly over a 20-week period until the option expires.\nWe will consider the following parameters for our simulation:\n\nInitial stock price: \\(S_0 = 49\\)\nStrike price: \\(K = 50\\)\nTime to expiration: \\(T = 0.3846\\) years (20 weeks)\nRisk-free interest rate: \\(r = 5\\%\\)\nVolatility (per annum): \\(\\sigma = 20\\%\\)\n\nWe also assume the option is sold at its theoretical price although this is not essential for our implementation and analysis."
  },
  {
    "objectID": "delta-hedging.html#a-step-by-step-implementation",
    "href": "delta-hedging.html#a-step-by-step-implementation",
    "title": "Delta Hedging a European Call Option",
    "section": "A Step-by-Step Implementation",
    "text": "A Step-by-Step Implementation\nIn this implementation, we simulate a single stock price path using Geometric Brownian Motion (GBM) and perform delta hedging step by step within a for loop.4 At each iteration, we record all relevant results to prepare for a tabular presentation. To maintain readability and ensure numerical consistency in the table, we round the values to appropriate decimal places.\n4 Later, when we investigate the relationship between hedging performance and rebalancing frequencies, we will eliminate the for loop and re-implement delta hedging with vectorized code to improve efficiency.We apply the alternative formulation discussed earlier to track the delta hedging process, i.e., setting \\(B_0 = - 100\\Delta_0 S_0\\). This approach ensures consistency with the table presentation in Hull (2021) (Chapter 19). With this formulation, the cumulative hedging cost is \\(-B_t\\), the negative of the cash position. The final hedging cost, excluding the initial option premium received, is given by \\(- \\varepsilon_T\\), the negative of the replication error.\nWe start by implementing the stock price simulation function simulate_gbm_path(). This implementation is explained in details in the GBM simulation tutorial.\n\n\nStock Price Simulation with GBM (click to expand)\nimport numpy as np\n\n# --- GBM simulation ---\ndef simulate_gbm_path(S0, mu, sigma, T, N, num_path, seed=None):\n\n    if seed is not None:\n        np.random.seed(seed)\n    \n    dt = T / N # Time step size\n    t = np.linspace(0, T, N+1) # Time grid; N+1 points to include t=0\n\n    # Generate all the standard normal shocks at once for all paths\n    eps = np.random.normal(size=(num_path, N))\n    \n    # Generate the Brownian motion paths; add W(0) = 0\n    W = np.cumsum(np.sqrt(dt) * eps, axis=1)\n    W = np.concatenate((np.zeros((num_path, 1)), W), axis=1)\n\n    # Calculate log-prices using vectorized operations\n    log_S = np.log(S0) + (mu - 0.5 * sigma**2) * t + sigma * W\n\n    # Exponentiate to get stock prices\n    return np.exp(log_S)\n\n\nNext we define a function to calculate the Black-Scholes delta.\n\nimport numpy as np\nfrom scipy.stats import norm\n\n# --- Black-Scholes delta ---\ndef calculate_bs_delta(S, K, T, r, sigma):\n    \n    # At expiration, delta is 1 if in-the-money, else 0\n    # Check this before d1 calculation to avoid division by zero\n    if T &lt;= 0:\n        return 1.0 if S &gt; K else 0.0\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n\n    return norm.cdf(d1)\n\nWe now implement the delta hedging logic step by step.\n\n# --- Delta Hedging Implementation ---\n# Parameters\nS0 = 49          # Initial stock price\nK = 50           # Strike price\nT = 20 / 52      # Time to expiration in years (20 weeks)\nr = 0.05         # Risk-free interest rate\nsigma = 0.2      # Volatility (20% per annum)\n\ncontract_size = 100000  # Number of shares per option contract\n\n# Simulation parameters\nN = 20           # Number of time steps (weekly rebalancing)\nnum_path = 1     # Number of simulated paths\n\n# Simulate stock price path\nS = simulate_gbm_path(S0, r, sigma, T, N, num_path, seed=37)\nS = S[0].round(2)  # Use the first (and only) path and round to 2 decimal places\n\n# Initialize arrays for delta hedging\ndelta = np.zeros(N + 1)\nshare_purchased = np.zeros(N + 1)\nshare_in_hand = np.zeros(N + 1)\ncost_of_share_purchased = np.zeros(N + 1)\ncost_of_interest = np.zeros(N + 1)\ncumulative_cost = np.zeros(N + 1)\n\n# Time to expiration at each step\nT_t = np.linspace(T, 0, N + 1)\n\n# Time step size\ndt = T / N\n\n# Initial hedge setup at t=0\ndelta[0] = round(calculate_bs_delta(S[0], K, T, r, sigma), 3)\nshare_purchased[0] = delta[0] * contract_size\nshare_in_hand[0] = share_purchased[0]\ncost_of_share_purchased[0] = round(share_purchased[0] * S[0] / 1000, 1)\ncumulative_cost[0] = cost_of_share_purchased[0]\ncost_of_interest[0] = round(cumulative_cost[0] * (np.exp(r * dt) - 1), 1)\n\n# Delta hedging over time\nfor i in range(1, N + 1):\n    delta[i] = round(calculate_bs_delta(S[i], K, T_t[i], r, sigma), 3)\n    delta_change = delta[i] - delta[i - 1]\n    share_purchased[i] = delta_change * contract_size\n    share_in_hand[i] = share_in_hand[i-1] + share_purchased[i]\n    cost_of_share_purchased[i] = round(share_purchased[i] * S[i] / 1000, 1)\n    cumulative_cost[i] = cumulative_cost[i-1] + cost_of_share_purchased[i] + cost_of_interest[i-1]\n    cost_of_interest[i] = round(cumulative_cost[i] * (np.exp(r * dt) - 1), 1)\n\ncost_of_interest[20] = np.nan  # No interest cost at maturity\n\n# Final stock price and shares held\nfinal_price  = S[-1]\nfinal_shares = share_in_hand[-1]\n\n# Option payoff at maturity\npayoff = max(final_price - K, 0) * contract_size / 1000\n\n# Stock value at maturity\nstock_value = final_price * final_shares / 1000\n\n# Value of hedging portfolio\nhedge_portfolio_value = stock_value - cumulative_cost[-1]\n\n# Final hedging cost\nhedging_cost = payoff - hedge_portfolio_value\n\n# Print results\nprint(f\"Final stock price: {final_price:.2f}\")\nprint(f\"Option payoff ($000): {payoff:.2f}\")\nprint(f\"Hedge portfolio value ($000): {hedge_portfolio_value:.2f}\")\nprint(f\"Final hedging cost ($000): {hedging_cost:.2f}\")\n\nFinal stock price: 62.41\nOption payoff ($000): 1241.00\nHedge portfolio value ($000): 1019.90\nFinal hedging cost ($000): 221.10\n\n\nWe now present the step-by-step delta hedging strategy in a well-formatted table (with the help of the Python great_tables library).\n\n\nDisplay step-by-step delta hedging (click to expand)\nimport pandas as pd\nfrom great_tables import GT, html\n\n# Create a DataFrame for printing results\ndf = pd.DataFrame({\n    \"week\": np.arange(N + 1),\n    \"stock_price\": S,\n    \"delta\": delta,\n    \"share_purchased\": share_purchased,\n    \"share_in_hand\": share_in_hand,\n    \"cost_of_share_purchased\": cost_of_share_purchased,\n    \"cumulative_cost\": cumulative_cost,\n    \"cost_of_interest\": cost_of_interest\n})\n\nfrom great_tables import GT, html\n\ngt_table = (\n    GT(df)\n    .fmt_integer(columns=[\"share_purchased\", \"share_in_hand\"],\n                 accounting=True)\n    .fmt_number(columns=[\"stock_price\"], decimals=2)\n    .fmt_number(columns=[\"delta\"], decimals=3)\n    .fmt_number(columns=[\"cost_of_share_purchased\", \"cumulative_cost\", \"cost_of_interest\"], \n                decimals=1,\n                accounting=True)\n    .tab_header(\n        title=\"Simulation of Delta Hedging\",\n        subtitle=\"(Weekly Rebalancing for a European Call Option on 100,000 Shares)\"\n    )\n    .cols_label(\n        week=\"Week\",\n        stock_price=html(\"Stock &lt;br&gt; price\"),\n        delta=\"Delta\",\n        share_purchased=html(\"Shares &lt;br&gt; purchased\"),\n        share_in_hand=html(\"Shares &lt;br&gt; in portfolio\"),\n        cost_of_share_purchased=html(\"Cost of shares &lt;br&gt; purchased &lt;br&gt; ($000)\"),\n        cumulative_cost=html(\"Cumulative cost &lt;br&gt; including interest &lt;br&gt; ($000)\"),\n        cost_of_interest=html(\"Interest &lt;br&gt; cost &lt;br&gt; ($000)\")\n    )\n    .cols_align(align=\"center\")\n)\n\ngt_table.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulation of Delta Hedging\n\n\n(Weekly Rebalancing for a European Call Option on 100,000 Shares)\n\n\nWeek\nStock\nprice\nDelta\nShares\npurchased\nShares\nin portfolio\nCost of shares\npurchased\n($000)\nCumulative cost\nincluding interest\n($000)\nInterest\ncost\n($000)\n\n\n\n\n0\n49.00\n0.522\n52,200\n52,200\n2,557.8\n2,557.8\n2.5\n\n\n1\n48.95\n0.514\n(800)\n51,400\n(39.2)\n2,521.1\n2.4\n\n\n2\n49.91\n0.576\n6,200\n57,600\n309.4\n2,832.9\n2.7\n\n\n3\n50.42\n0.608\n3,200\n60,800\n161.3\n2,996.9\n2.9\n\n\n4\n48.66\n0.480\n(12,800)\n48,000\n(622.8)\n2,377.0\n2.3\n\n\n5\n50.78\n0.630\n15,000\n63,000\n761.7\n3,141.0\n3.0\n\n\n6\n52.23\n0.726\n9,600\n72,600\n501.4\n3,645.4\n3.5\n\n\n7\n52.66\n0.756\n3,000\n75,600\n158.0\n3,806.9\n3.7\n\n\n8\n52.04\n0.721\n(3,500)\n72,100\n(182.1)\n3,628.5\n3.5\n\n\n9\n53.48\n0.814\n9,300\n81,400\n497.4\n4,129.4\n4.0\n\n\n10\n52.29\n0.747\n(6,700)\n74,700\n(350.3)\n3,783.1\n3.6\n\n\n11\n53.11\n0.808\n6,100\n80,800\n324.0\n4,110.7\n4.0\n\n\n12\n54.98\n0.911\n10,300\n91,100\n566.3\n4,681.0\n4.5\n\n\n13\n55.81\n0.948\n3,700\n94,800\n206.5\n4,892.0\n4.7\n\n\n14\n55.74\n0.957\n900\n95,700\n50.2\n4,946.9\n4.8\n\n\n15\n55.72\n0.968\n1,100\n96,800\n61.3\n5,013.0\n4.8\n\n\n16\n55.82\n0.981\n1,300\n98,100\n72.6\n5,090.4\n4.9\n\n\n17\n58.14\n0.999\n1,800\n99,900\n104.7\n5,200.0\n5.0\n\n\n18\n61.32\n1.000\n100\n100,000\n6.1\n5,211.1\n5.0\n\n\n19\n62.04\n1.000\n0\n100,000\n0.0\n5,216.1\n5.0\n\n\n20\n62.41\n1.000\n0\n100,000\n0.0\n5,221.1\n\n\n\n\n\n\n\n\n\nIn this simulation, the initial stock price is \\(\\$49\\), and the initial BS delta is \\(0.522\\). Accordingly, \\(0.522 \\times 100,000 = 52,200\\) shares must be purchased to establish the initial hedge portfolio. The cost of acquiring these shares is \\(\\$49 \\times 52,200 = \\$2,557.8K\\). Since there is no interest cost at \\(t=0\\), the cumulative cost at this point is also \\(\\$2,557.8K\\).\nAt the end of week 1, the interest cost amounts to \\(\\$2,557.8K \\times (e^{0.05 \\times 1/52} - 1) \\approx \\$2.5K\\). This is added to the cumulative cost, along with the cost (or proceeds) from rebalancing the hedge. In our case, since the delta decreases from \\(0.522\\) to \\(0.514\\), a change of \\(0.008\\), the portfolio sells \\(0.008 \\times 100,000 = 800\\) shares at \\(\\$48.95\\) per each to maintain neutrality, producing a cash inflow of approximately \\(\\$39.2K\\). Thus, the cumulative cost at the end of week 1 becomes \\(\\$2,557.8K - \\$39.2K + \\$2.5K = \\$2,521.1K\\).\nAt expiration, the option closes in-the-money, resulting in a positive option payoff. The final hedging cost of \\(\\$221.1K\\) is the cumulative rebalancing cost \\(\\$5,221.1K\\) minus the \\(\\$5\\) million received from the option holder at expiration (i.e., the \\(100,000\\) shares at the option seller’s hedging portfolio is paid at the predetermined strike price of \\(\\$50\\)).\nEquivalently, the final hedging cost can also be computed as the negative of the replication error (\\(-\\varepsilon_T\\)), which equals the difference between the option payoff and the value of the hedging portfolio at expiration. The option payoff is \\((\\$62.41 - \\$50) \\times 100,000\\), corresponding to exercising the option to purchase \\(100,000\\) shares at the strike price of \\(\\$50\\) when the stock price is \\(\\$62.41\\) at expiration. The value of the hedging portfolio equals the stock position value \\(\\$62.41 \\times 100,000\\) minus the cumulative hedging cost of \\(\\$5,221.1K\\).\nNext, we generate a different stock price path where the option expires out of the money to examine how the delta hedging strategy performs in this scenario.5 Below we present the results.\n5 The random seed used to generate this stock price path is 42.\n\nFinal stock price: 45.08\nOption payoff ($000): 0.00\nHedge portfolio value ($000): -238.80\nFinal hedging cost ($000): 238.80\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulation of Delta Hedging\n\n\n(Weekly Rebalancing for a European Call Option on 100,000 Shares)\n\n\nWeek\nStock\nprice\nDelta\nShares\npurchased\nShares\nin portfolio\nCost of shares\npurchased\n($000)\nCumulative cost\nincluding interest\n($000)\nInterest\ncost\n($000)\n\n\n\n\n0\n49.00\n0.522\n52,200\n52,200\n2,557.8\n2,557.8\n2.5\n\n\n1\n49.71\n0.565\n4,300\n56,500\n213.8\n2,774.1\n2.7\n\n\n2\n49.55\n0.551\n(1,400)\n55,100\n(69.4)\n2,707.4\n2.6\n\n\n3\n50.47\n0.611\n6,000\n61,100\n302.8\n3,012.8\n2.9\n\n\n4\n52.68\n0.747\n13,600\n74,700\n716.4\n3,732.1\n3.6\n\n\n5\n52.37\n0.732\n(1,500)\n73,200\n(78.6)\n3,657.1\n3.5\n\n\n6\n52.06\n0.716\n(1,600)\n71,600\n(83.3)\n3,577.3\n3.4\n\n\n7\n54.42\n0.847\n13,100\n84,700\n712.9\n4,293.6\n4.1\n\n\n8\n55.63\n0.899\n5,200\n89,900\n289.3\n4,587.0\n4.4\n\n\n9\n54.94\n0.882\n(1,700)\n88,200\n(93.4)\n4,498.0\n4.3\n\n\n10\n55.80\n0.920\n3,800\n92,000\n212.0\n4,714.3\n4.5\n\n\n11\n55.12\n0.906\n(1,400)\n90,600\n(77.2)\n4,641.6\n4.5\n\n\n12\n54.45\n0.890\n(1,600)\n89,000\n(87.1)\n4,559.0\n4.4\n\n\n13\n54.85\n0.918\n2,800\n91,800\n153.6\n4,717.0\n4.5\n\n\n14\n52.04\n0.760\n(15,800)\n76,000\n(822.2)\n3,899.3\n3.8\n\n\n15\n49.64\n0.497\n(26,300)\n49,700\n(1,305.5)\n2,597.6\n2.5\n\n\n16\n48.90\n0.381\n(11,600)\n38,100\n(567.2)\n2,032.9\n2.0\n\n\n17\n47.57\n0.170\n(21,100)\n17,000\n(1,003.7)\n1,031.2\n1.0\n\n\n18\n48.02\n0.168\n(200)\n16,800\n(9.6)\n1,022.6\n1.0\n\n\n19\n46.85\n0.011\n(15,700)\n1,100\n(735.5)\n288.1\n0.3\n\n\n20\n45.08\n0.000\n(1,100)\n0\n(49.6)\n238.8\n\n\n\n\n\n\n\n\n\nSince the initial condition is the same as before, the hedging portfolio is established in exactly the same way. By the end of week 1, the stock price rises, leading to an increase in the option’s delta. Accordingly, additional shares are purchased to rebalance the hedge.\nAt the end of week 20, the stock price falls to \\(\\$45.08\\), and the option expires out of the money with a payoff of zero. The final hedging cost is therefore the cumulative cost of rebalancing the hedge over the 20 weeks. This amounts to \\(\\$238.8K\\).\nSimilarly, the final hedging cost can be calculated as the negative of the replication error (\\(-\\varepsilon_T\\)). In this case, the option payoff is zero. The value of the hedging portfolio is given by the value of the stock position, which is zero as no stocks are held at the end of week 20, minus the cumulative hedging cost of \\(\\$238.8K\\). The final hedging cost is therefore \\(0 - (\\$0 - \\$238.8K) = \\$238.8K\\)."
  },
  {
    "objectID": "delta-hedging.html#a-vectorized-implementation",
    "href": "delta-hedging.html#a-vectorized-implementation",
    "title": "Delta Hedging a European Call Option",
    "section": "A Vectorized Implementation",
    "text": "A Vectorized Implementation\nTo enhance computational efficiency, especially when performing delta hedging on multiple simulated stock price paths, we can implement the delta hedging strategy using vectorized operations with Python’s NumPy library. This approach eliminates the need for explicit loops, enabling more efficient handling of large-scale simulations.\nSince our stock price path simulation function, simulate_gbm_path(), is already vectorized to support multiple paths, we begin by defining a vectorized version of the Black–Scholes delta function capable of processing arrays of stock prices and times to expiration.\n\n# ndtr from scipy.special is faster than norm.cdf from scipy.stats\nfrom scipy.special import ndtr\n\n# --- Black-Scholes delta (vectorized) ---\n1def calculate_bs_delta(S, K, T, r, sigma):\n    # Avoid division by zero inside sqrt\n    eps = 1e-12\n    t_safe = np.maximum(T, eps)\n\n    # Use t_safe in both numerator and denominator for consistency\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * t_safe) / (\n        sigma * np.sqrt(t_safe)\n    )\n\n    # Use scipy's ndtr for fast cumulative normal distribution calculation\n    delta = ndtr(d1)\n\n    # At expiration: delta = 1 if S &gt; K else 0\n    delta = np.where(T &lt;= 0, (S &gt; K).astype(float), delta)\n\n    return delta\n\n\n1\n\nThis function can handle array inputs for S and T, returning an array of delta values. In the code below when the function is called, the shape of S is (num_path, N+1), and the shape of T is (N+1,). Broadcasting rules in NumPy will ensure that the operations are performed correctly across these dimensions. The returned delta will have the shape (num_path, N+1).\n\n\n\n\nNext, we implement the delta hedging logic in a vectorized manner. This function simulates multiple stock price paths and calculates the hedging costs for all paths at once.\n\n# --- Delta Hedging (Vectorized) ---\ndef delta_hedge(S0, K, T, r, sigma, contract_size, N, num_path, seed=None):\n    \n    # Simulate stock price paths; shape: (num_path, N+1)\n    S = simulate_gbm_path(S0, r, sigma, T, N, num_path, seed=seed)  \n\n    # Time to expiration at each step; shape: (N+1,)\n    T_t = np.linspace(T, 0, N + 1)\n\n    # Calculate interest factors for cash account; shape : (N+1,)\n    interest_factor = np.exp(r * T_t)\n\n    # Calculate deltas and changes in deltas; shape: (num_path, N+1)\n    delta = calculate_bs_delta(S, K, T_t, r, sigma)\n    delta_change = np.diff(delta, axis=1, prepend=0)\n\n    # Cost of purchasing shares at each step; shape: (num_path, N+1)\n    cost_of_share_purchased = (delta_change * contract_size * S)\n\n    # Cumulative cost adjusted for interest; shape: (num_path,)\n    cumulative_cost = np.sum(cost_of_share_purchased * interest_factor, axis=1)\n\n    # Option payoff at maturity; shape: (num_path,)\n    payoff = np.maximum(S[:,-1] - K, 0) * contract_size\n\n    # hedge portfolio value at maturity; shape: (num_path,)\n    hedge_portfolio_value = S[:,-1] * (delta[:,-1] * contract_size) - cumulative_cost\n\n    # Final hedging cost (rebalancing costs + replication error); shape: (num_path,)\n    hedging_cost = payoff - hedge_portfolio_value\n\n    return hedging_cost\n\nWe run two tests to verify the correctness of our vectorized implementation. Both tests use the same parameters as before (including the same random seeds), and both will simulate two paths. Generating two paths allows us to confirm that the function handles multiple paths correctly. We compare the hedging cost of the first path in each test against the results from our earlier step-by-step implementation.\n\n# Parameters\nS0 = 49          # Initial stock price\nK = 50           # Strike price\nT = 20 / 52      # Time to expiration in years (20 weeks)\nr = 0.05         # Risk-free interest rate\nsigma = 0.2      # Volatility (20% per annum)\n\ncontract_size = 100_000  # Number of shares per option contract\n\n# Simulation parameters\nN = 20           # Number of time steps (weekly rebalancing)\nnum_path = 2     # Number of simulated paths\n\n# Run the vectorized delta hedging function\nresults_seed37 = delta_hedge(S0, K, T, r, sigma, contract_size, N, num_path, seed=37)\nresults_seed42 = delta_hedge(S0, K, T, r, sigma, contract_size, N, num_path, seed=42)\n\n# Print the average hedging cost\nprint(\"Final hedging cost ($000; seed 37):\",\n      np.array2string(results_seed37/1000, precision=2, separator=', '))\nprint(\"Final hedging cost ($000; seed 42):\",\n      np.array2string(results_seed42/1000, precision=2, separator=', '))\n\nFinal hedging cost ($000; seed 37): [220.51, 257.92]\nFinal hedging cost ($000; seed 42): [238.62, 234.82]\n\n\nIn the first test (seed 37), we expect the hedging cost of the first path to be approximately \\(\\$221.10\\) (in 000s), and we get \\(220.51\\). In the second test (seed 42), we expect the hedging cost of the first path to be about \\(\\$238.80\\) (in 000s), and we get \\(238.62\\). The results confirm that the hedging cost of the first path in each test closely matches the outcome from our step-by-step implementation, with only minor discrepancies attributable to rounding errors in the step-by-step approach. The second path in each test is newly generated so it yields different hedging costs.\nWe are now prepared to analyze the hedging performance across various rebalancing frequencies. Following the approach in Hull (2021) (Chapter 19), we consider rebalancing intervals ranging from once every five weeks to four times per week. For each frequency, we simulate \\(1,000,000\\) stock price paths and evaluate the hedging performance by calculating the standard deviation of the hedging cost relative to the theoretical option price.\n\nHull, J. 2021. Options, Futures, and Other Derivatives. Business and Economics. Pearson. https://www-2.rotman.utoronto.ca/~hull/ofod/index.html.\n\n# Black-Scholes formula to calculate the theoretical option price\ndef calculate_bs_call_price(S0, K, T, r, sigma):\n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    call_price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return call_price\n\n# Parameters\nS0 = 49          # Initial stock price\nK = 50           # Strike price\nT = 20 / 52      # Time to expiration in years (20 weeks)\nr = 0.05         # Risk-free interest rate\nsigma = 0.2      # Volatility (20% per annum)\n\ncontract_size = 100_000  # Number of shares per option contract\n\noption_price = calculate_bs_call_price(S0, K, T, r, sigma) * contract_size\nprint(f\"Theoretical option price ($000): {option_price/1000:.2f}\")\n\n# Simulation parameters\nN = 20           # Number of time steps (weekly rebalancing)\nnum_path = 1_000_000     # Number of simulated paths\n\n# Run delta hedging for different rebalancing frequencies\nfrequencies = [5, 4, 2, 1, 0.5, 0.25]  # in weeks\nresults = {}\nfor freq in frequencies:\n    N_steps = int(N / freq)  # Convert frequency in weeks to number of steps\n    hedging_costs = delta_hedge(S0, K, T, r, sigma, contract_size, N_steps, num_path, seed=42)\n    results[freq] = hedging_costs\n\n# Display the result in a simple table\nprint(\"\\nHedging Performance for Different Rebalancing Frequencies:\")\nprint(\"-\" * 60)\nprint(\"Frequency | Mean Cost | Std Dev  | Hedging Performance\")\nprint(\" (weeks)  |  ($000)   |  ($000)  | (Std Dev / Option Price)\")\nprint(\"-\" * 60)\nfor freq, costs in results.items():\n    cost_time_0 = costs * np.exp(-r * T)  # Adjust cost to time 0 value\n    mean_cost = np.mean(cost_time_0) / 1000  # Convert to 000s\n    std_cost = np.std(cost_time_0) / 1000  # Convert to 000s\n    hedging_performance = std_cost / (option_price / 1000)  # Ratio of std to option price\n    print(f\"   {freq:.2f}   |  {mean_cost:.2f}   |  {std_cost:5.2f}   |  {hedging_performance:.2f}\")\n\nTheoretical option price ($000): 240.05\n\nHedging Performance for Different Rebalancing Frequencies:\n------------------------------------------------------------\nFrequency | Mean Cost | Std Dev  | Hedging Performance\n (weeks)  |  ($000)   |  ($000)  | (Std Dev / Option Price)\n------------------------------------------------------------\n   5.00   |  240.16   |  98.38   |  0.41\n   4.00   |  240.18   |  88.82   |  0.37\n   2.00   |  240.08   |  64.17   |  0.27\n   1.00   |  240.09   |  46.08   |  0.19\n   0.50   |  240.04   |  33.01   |  0.14\n   0.25   |  240.07   |  23.52   |  0.10\n\n\nAs expected, the average hedging cost across all simulated paths is slightly larger than the theoretical option price. Increasing the rebalancing frequency brings the average hedging cost closer to the theoretical value. Nevertheless, with discrete rebalancing, replication error will always remain.\nOn the other hand, hedging performance improves as the rebalancing frequency increases. More frequent adjustments allow for better alignment with the option’s delta, thereby reducing overall risk."
  },
  {
    "objectID": "delta-hedging.html#references",
    "href": "delta-hedging.html#references",
    "title": "Delta Hedging a European Call Option",
    "section": "References",
    "text": "References\nHull, J. C. (2021). Options, Futures, and Other Derivatives (11th ed.). Pearson."
  },
  {
    "objectID": "option-bi-tree.html",
    "href": "option-bi-tree.html",
    "title": "Pricing Options Using Binomial Trees",
    "section": "",
    "text": "This tutorial demonstrates how to price European and American options using a binomial tree model in Python. The binomial tree model is a popular method for option pricing due to its simplicity and flexibility."
  },
  {
    "objectID": "option-bi-tree.html#introduction",
    "href": "option-bi-tree.html#introduction",
    "title": "Pricing Options Using Binomial Trees",
    "section": "",
    "text": "This tutorial demonstrates how to price European and American options using a binomial tree model in Python. The binomial tree model is a popular method for option pricing due to its simplicity and flexibility."
  },
  {
    "objectID": "option-bi-tree.html#recap-binomial-tree-model",
    "href": "option-bi-tree.html#recap-binomial-tree-model",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Recap: Binomial Tree Model",
    "text": "Recap: Binomial Tree Model\nThe binomial tree model is a discrete-time model for the evolution of an asset’s price. It assumes that, over each small time step, the asset price can move to one of two possible values: an “up” value or a “down” value. The model is built on the following parameters:\n\nCurrent stock price: \\(S_0\\)\nStrike price of the option: \\(K\\)\nTime to maturity (in years): \\(T\\)\nRisk-free interest rate (annualized): \\(r\\)\nVolatility of the underlying asset (annualized): \\(\\sigma\\)\nNumber of time steps in the binomial tree: \\(N\\)\n\nFrom these parameters, we can calculate the parameters needed for the binomial tree:\n\nLength of each time step: \\(\\Delta t = \\frac{T}{N}\\)\nUp factor: \\(u = e^{\\sigma \\sqrt{\\Delta t}}\\)\nDown factor: \\(d = 1/u\\)\nRisk-neutral probability of an up move: \\(p = \\frac{e^{r \\Delta t} - d}{u - d}\\)\n\nAsset prices at each node of the tree can be calculated as follows:\n\\[S_{j,i} = S_0 \\cdot u^{i-j} \\cdot d^{j},\\]\nwhere \\(i={0,1,2,...,N}\\) is the time step and \\(j={0,1,2,...,i}\\) is the number of down moves.1\n1 The notation and formula are chosen such that it matches the code implementation later.The value of options can be calculated using backward induction, starting from the terminal nodes (maturity) and working backward to the root node (current time).\nThe value of the option at end of the tree is determined by its payoff at maturity. For a call option, the payoff is given by (denote \\(f_{j, i}\\) as the option value at node \\(j\\) at time step \\(i\\)):\n\\[f_{j, N} = \\max(0, S_{j, N} - K)\\]\nFor a put option, the payoff is given by:\n\\[f_{j, N} = \\max(0, K - S_{j, N})\\]\nThe option value at each preceding node is calculated as the discounted expected value of the option at the next time step:\n\\[f_{j, i} = e^{-r \\Delta t} [p \\cdot f_{j, i+1} + (1 - p) \\cdot f_{j+1, i+1}]\\]\nFor American options, we also need to consider the possibility of early exercise at each node:\n\\[f_{j, i} = \\max(f_{j, i}, S_{j, i} - K)\\]\nFor a detailed explanation of the binomial tree model, please refer to Hull (2021) (chapter 13 and 21).\n\nHull, J. 2021. Options, Futures, and Other Derivatives. Business and Economics. Pearson. https://www-2.rotman.utoronto.ca/~hull/ofod/index.html."
  },
  {
    "objectID": "option-bi-tree.html#basic-algorithm",
    "href": "option-bi-tree.html#basic-algorithm",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Basic Algorithm",
    "text": "Basic Algorithm\nImplementing the binomial tree model involves the following steps:\n\nParameters: Define the parameters for the option and the underlying asset. Calculate the binomial tree parameters.\nTree Construction: Construct a binomial tree to store the possible future prices of the option and the underlying asset at each time step. In our implementation, we use 2D arrays to represent the binomial tree. Therefore, effectively, only the upper triangles of the arrays are used.2 We construct three 2D arrays: one for asset prices, one for option values, and one to track whether the option is exercised at each node.3\n\n2 For example, for a tree with \\(N=2\\), we create a 2D array with 3 rows and 3 columns to store option values. However, we really just need the upper triangle (including the diagonal) of the array to store the option values for all nodes:\nMatrix representation: \\[\n\\begin{bmatrix}\nf_{0,0} & f_{0,1} & f_{0,2} \\\\\n0 & f_{1,1} & f_{1,2} \\\\\n0 & 0 & f_{2,2}\n\\end{bmatrix}\n\\]3 We use 2D arrays mainly for clarity and visualization purpose. In practice, if intermediate results are not needed, we can optimize the memory usage by using 1D arrays, as shown later.\nAsset Price Calculation: Calculate the asset prices at each node of the tree using the up and down factors.\nOption Valuation: Calculate the option value at each node of the tree, starting from the terminal nodes (maturity) and working backward to the root node (current time). For European options, the option can only be exercised at maturity, while for American options, it can be exercised at any time before or at maturity."
  },
  {
    "objectID": "option-bi-tree.html#pricing-a-european-call-option",
    "href": "option-bi-tree.html#pricing-a-european-call-option",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Pricing a European Call Option",
    "text": "Pricing a European Call Option\nWe start by pricing a European call option using a binomial tree with 2 time steps.\n\nimport numpy as np\n\n# Parameters\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 2     # Number of time steps\n\n# Calculate parameters for the binomial tree\ndt = T / N  # Time step size\nu = np.exp(sigma * np.sqrt(dt))  # Up factor\nd = 1 / u  # Down factor\np = (np.exp(r * dt) - d) / (u - d)  # Risk-neutral probability\n\n# Initialize three 2D arrays to represent the binomial tree\n# One for asset prices, one for option values, and one to track exercises\nasset_prices = np.zeros((N + 1, N + 1))\noption_values = np.zeros((N + 1, N + 1))\nexercises = np.zeros((N + 1, N + 1), dtype=bool)\n\n# Set asset prices at each node\nfor i in range(N + 1):\n    for j in range(i + 1):\n        asset_prices[j, i] = S0 * (u ** (i - j)) * (d ** j)\n\n# Set option values at maturity\noption_values[:, N] = np.maximum(0, asset_prices[:, N] - K)\n\n# Set exercise values at maturity\nexercises[:, N] = (asset_prices[:, N] - K) &gt; 0\n\n# Backward induction to calculate option price at earlier nodes\nfor i in range(N - 1, -1, -1):\n    # Time step i\n\n    for j in range(i + 1):\n        # Update option values\n        option_values[j, i] = np.exp(-r * dt) * (p * option_values[j, i + 1] + (1 - p) * option_values[j + 1, i + 1])\n\n# Display parameters and option price\nprint(\"Strike Price:\", K)\nprint(f\"Time to Maturity (T): {T} year(s)\")\nprint(f\"Time Step (dt): {dt:.4f} year(s)\")\nprint(f\"Discount Factor per Step: {np.exp(-r * dt):.4f}\")\nprint(f\"Risk-neutral Probability (p): {p:.4f}\")\nprint(f\"Up Factor (u): {u:.4f}\")\nprint(f\"Down Factor (d): {d:.4f}\")\nprint()\nprint(f\"Option Price: {option_values[0, 0]:.4f}\")\n\nStrike Price: 100\nTime to Maturity (T): 1 year(s)\nTime Step (dt): 0.5000 year(s)\nDiscount Factor per Step: 0.9753\nRisk-neutral Probability (p): 0.5539\nUp Factor (u): 1.1519\nDown Factor (d): 0.8681\n\nOption Price: 9.5405\n\n\nWe can visualize the binomial tree structure and the option values at each node.\n\n\nDefine a function to plot the binomial tree (click to expand)\n# Plotting the Binomial Tree\nimport matplotlib.pyplot as plt\n\ndef plot_binomial_tree(asset_prices, option_values, exercises, N):\n    fig, ax = plt.subplots()\n    for i in range(N + 1):\n        for j in range(i + 1):\n            x = i  # Set x-coordinate based on time step\n            y = i - 2 * j  # Adjust y-coordinate for symmetry\n            \n            # Plot the node\n            if exercises[j, i]:\n                fcolor = 'lemonchiffon'  # Color for exercised nodes\n            else:\n                fcolor = 'white'  # Color for non-exercised nodes\n            \n            ax.text(x, y, \n                f\"S: {asset_prices[j, i]:.2f}\\nf: {option_values[j, i]:.2f}\", \n                ha='center', va='center', \n                bbox=dict(facecolor=fcolor, edgecolor='black'))\n            \n            # Draw branches\n            if i &lt; N:\n                ax.plot([x, x + 1], [y, y - 1], 'k-')  # Downward branch\n                ax.plot([x, x + 1], [y, y + 1], 'k-')  # Upward branch\n  \n    # Set limits and labels\n    ax.set_xlim(0, N)\n    ax.set_ylim(-N - 1, N + 1)\n    ax.set_xlabel('Time Steps')\n\n    # Set x-ticks (start from 0 and increment by 1)\n    ax.set_xticks(range(N + 1))\n    \n    # Remove unnecessary spines and ticks\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    ax.yaxis.set_visible(False)\n\n    ax.set_title('Binomial Tree for Option Pricing')\n\n    plt.show()\n\n\n\n# Plot the tree\nplot_binomial_tree(asset_prices, option_values, exercises, N)"
  },
  {
    "objectID": "option-bi-tree.html#pricing-a-american-put-option",
    "href": "option-bi-tree.html#pricing-a-american-put-option",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Pricing a American Put Option",
    "text": "Pricing a American Put Option\nThe process for pricing an American put option is similar, but we need to account for the possibility of early exercise at each node. (Three code changes are marked in the comments.)\n\nimport numpy as np\n\n# Parameters\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 4     # Number of time steps\n\n# Calculate parameters for the binomial tree\ndt = T / N  # Time step size\nu = np.exp(sigma * np.sqrt(dt))  # Up factor\nd = 1 / u  # Down factor\np = (np.exp(r * dt) - d) / (u - d)  # Risk-neutral probability\n\n# Initialize three 2D arrays to represent the binomial tree\n# One for asset prices, one for option values, and one to track exercises\nasset_prices = np.zeros((N + 1, N + 1))\noption_values = np.zeros((N + 1, N + 1))\nexercises = np.zeros((N + 1, N + 1), dtype=bool)\n\n# Set asset prices at each node\nfor i in range(N + 1):\n    for j in range(i + 1):\n        asset_prices[j, i] = S0 * (u ** (i - j)) * (d ** j)\n\n# Set option values at maturity (Change 1)\noption_values[:, N] = np.maximum(0, K - asset_prices[:, N])\n\n# Set exercise values at maturity (Change 2)\nexercises[:, N] = (K - asset_prices[:, N]) &gt; 0\n\n# Backward induction to calculate option price at earlier nodes\nfor i in range(N - 1, -1, -1):\n    # Time step i\n\n    for j in range(i + 1):\n        # Update option values\n        option_values[j, i] = np.exp(-r * dt) * (p * option_values[j, i + 1] + (1 - p) * option_values[j + 1, i + 1])\n\n        # Check for early exercise and update option values accordingly (Change 3)\n        exercises[j, i] = (K - asset_prices[j, i]) &gt; option_values[j, i]\n        option_values[j, i] = np.maximum(option_values[j, i], K - asset_prices[j, i])\n\n# Display parameters and option price\nprint(\"Strike Price:\", K)\nprint(f\"Time to Maturity (T): {T} year(s)\")\nprint(f\"Time Step (dt): {dt:.4f} year(s)\")\nprint(f\"Discount Factor per Step: {np.exp(-r * dt):.4f}\")\nprint(f\"Risk-neutral Probability (p): {p:.4f}\")\nprint(f\"Up Factor (u): {u:.4f}\")\nprint(f\"Down Factor (d): {d:.4f}\")\nprint()\nprint(f\"Option Price: {option_values[0, 0]:.4f}\")\n\nStrike Price: 100\nTime to Maturity (T): 1 year(s)\nTime Step (dt): 0.2500 year(s)\nDiscount Factor per Step: 0.9876\nRisk-neutral Probability (p): 0.5378\nUp Factor (u): 1.1052\nDown Factor (d): 0.9048\n\nOption Price: 5.8828\n\n\n\n# Plot the tree\nplot_binomial_tree(asset_prices, option_values, exercises, N)"
  },
  {
    "objectID": "option-bi-tree.html#putting-it-all-together-with-efficiency-improvements",
    "href": "option-bi-tree.html#putting-it-all-together-with-efficiency-improvements",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Putting It All Together with Efficiency Improvements",
    "text": "Putting It All Together with Efficiency Improvements\nWe can encapsulate the binomial tree option pricing logic into a single function that can handle both European and American options, as well as call and put options.\nIn this implementation, we are not interested in storing the entire binomial tree structure for visualization purposes. On the other hand, we focus on optimizing the efficiency of the algorithm.\n\nSince during the backward induction process, we only need the current and next time step values, we can reduce the memory usage by using 1D arrays instead of 2D arrays.\nAt each time step, instead of looping through all nodes, we can use Numpy’s vectorized operations and array slicing to update only the relevant parts of the 1D arrays. NumPy’s internal optimizations make these operations faster than explicit Python loops.\n\nThese optimizations will be particularly useful when dealing with a large number of time steps.\n\nimport numpy as np\n\ndef binomial_tree(S0, K, T, r, sigma, N, call=True, american=False):\n    # Calculate parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n\n    # Initialize two 1D arrays to keep track of asset prices and option values\n    # These arrays will be updated in place during the backward induction at each time step\n    # Only the necessary parts of the arrays will be used when updating\n    S = np.zeros(N + 1)\n    f = np.zeros(N + 1)\n\n    # Set asset prices at maturity\n    # Note: since d = 1 / u, the calculation can be simplified\n    S = S0 * u ** np.arange(N, -N - 2, -2)\n\n    # Set option values at maturity\n    if call:\n        f = np.maximum(0, S - K)\n    else:\n        f = np.maximum(0, K - S)\n\n    # Backward induction to calculate option price at earlier nodes\n    for i in range(N - 1, -1, -1):\n        # Time step i\n        \n        # Only the first i+1 elements need to be updated at this step\n        last_idx = i + 1\n\n        # Update option values\n        f[:last_idx] = np.exp(-r * dt) * (p * f[:last_idx] + (1 - p) * f[1:last_idx + 1])\n        \n        # For American options, check for early exercise\n        if american:\n            # Update asset prices\n            S[:last_idx] = S0 * u ** np.arange(i, -i - 2, -2)\n            \n            # Check for early exercise and update option values accordingly\n            if call:\n                f[:last_idx] = np.maximum(f[:last_idx], S[:last_idx] - K)\n            else:\n                f[:last_idx] = np.maximum(f[:last_idx], K - S[:last_idx])\n\n    return f[0]\n\nLet’s apply this function using the same parameters as before.\n\n# European Call Option\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 2     # Number of time steps\ncall = True  # True for Call option, False for Put option\namerican = False  # True for American option, False for European\n\n# Calculate option price\noption_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"Option Price: {option_price:.4f}\")\n\nOption Price: 9.5405\n\n\n\n# American Put Option\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 4     # Number of time steps\ncall = False  # True for Call option, False for Put option\namerican = True  # True for American option, False for European\n\n# Calculate option price\noption_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"Option Price: {option_price:.4f}\")\n\nOption Price: 5.8828\n\n\nNote that the results match those obtained from the previous implementations.\nFinally, let’s use a larger number of time steps to get more accurate results.\n\n# European Call Option\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 15000    # Number of time steps\ncall = True  # True for Call option, False for Put option\namerican = False  # True for American option, False for European\n\n# Calculate option price\nec_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"European Call Option Price: {ec_price:.4f}\")\n\n# American Put Option\ncall = False  # True for Call option, False for Put option\namerican = True  # True for American option, False for European\n\n# Calculate option price\nap_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"American Put Option Price: {ap_price:.4f}\")\n\nEuropean Call Option Price: 10.4505\nAmerican Put Option Price: 6.0903\n\n\nSince Black-Scholes formula can be used for pricing European options, we can compare the European call option price with the Black-Scholes price.\n\nfrom scipy.stats import norm\n\ndef black_scholes_european_call(S0, K, T, r, sigma):\n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n\n# Calculate Black-Scholes price for European call option\nbs_price = black_scholes_european_call(S0, K, T, r, sigma)\nprint(f\"Black-Scholes European Call Option Price: {bs_price:.4f}\")\n\nBlack-Scholes European Call Option Price: 10.4506\n\n\nWe see the European call option price from the binomial tree model is very close to the Black-Scholes price."
  },
  {
    "objectID": "option-bi-tree.html#references",
    "href": "option-bi-tree.html#references",
    "title": "Pricing Options Using Binomial Trees",
    "section": "References",
    "text": "References\nHull, J. C. (2021). Options, Futures, and Other Derivatives (11th ed.). Pearson."
  }
]