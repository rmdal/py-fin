[
  {
    "objectID": "util_approximation.html",
    "href": "util_approximation.html",
    "title": "Appendix: Why the Mean-Variance Objective?",
    "section": "",
    "text": "Why is the mean–variance (MV) objective function \\[\n\\max_w \\mathbf{w}^T \\mathbf{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}\n\\] a valid approximation of investor preferences?\nHere is one justification of the Mean-Variance optimization problem using the Taylor Series Approximation. Refer to Levy and Markowitz (1979) for more on this topic.\n\nLevy, H., and H. M. Markowitz. 1979. “Approximating Expected Utility by a Function of Mean and Variance.” The American Economic Review 69 (3): 308–17. http://www.jstor.org/stable/1807366.\n\nThe Goal\nWe start with an investor who wants to maximize the expected utility of their final wealth, \\(E[U(W)]\\). We want to show that it can be approxmiated by the optimization problem: \\(\\max_w \\mathbf{w}^T \\mathbf{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}\\).\n\n\nStep 1: The Setup\nLet\n\n\\(W\\) be the random variable representing final wealth\n\\(\\mu_W = E[W]\\) be the expected final wealth\n\\(\\sigma^2_W = E[(W - \\mu_W)^2]\\) be the variance of final wealth\n\\(U(W)\\) be a utility function where \\(U'&gt;0\\) (more wealth is good) and \\(U''&lt;0\\) (risk aversion)\n\nWe define the Certainty Equivalent (CE), the guaranteed cash amount that provides the same utility as the risky wealth \\(W\\). \\[U(CE) = E[U(W)]\\]\nSince utility increases with wealth, maximizing Expected Utility is equivalent to maximizing the Certainty Equivalent (CE).\n\n\nStep 2: Approximating the “Risky” Side (\\(E[U(W)]\\))\nWe approximate the utility of the random wealth \\(W\\) using a second-order Taylor Series expansion around the expected wealth \\(\\mu_W\\).\n\\[U(W) \\approx U(\\mu_W) + U'(\\mu_W)(W - \\mu_W) + \\frac{1}{2}U''(\\mu_W)(W - \\mu_W)^2\\]\nNow, we apply the expectation operator \\(E[\\cdot]\\) to the entire equation:\n\\[E[U(W)] \\approx E[U(\\mu_W)] + E[U'(\\mu_W)(W - \\mu_W)] + E\\left[\\frac{1}{2}U''(\\mu_W)(W - \\mu_W)^2\\right]\\]\nSince \\(\\mu_W\\), \\(U(\\mu_W)\\), and its derivatives are constants, they move outside the expectation:\n\\[E[U(W)] \\approx U(\\mu_W) + U'(\\mu_W)\\underbrace{E[W - \\mu_W]}_{0} + \\frac{1}{2}U''(\\mu_W)\\underbrace{E[(W - \\mu_W)^2]}_{\\sigma^2_W}\\]\nNote: The middle term is zero because the expected deviation from the mean is always zero.\nResult A: \\[E[U(W)] \\approx U(\\mu_W) + \\frac{1}{2}U''(\\mu_W)\\sigma^2_W\\]\n\n\nStep 3: Approximating the “Certainty” Side (\\(U(CE)\\))\nWe also approximate the utility of the Certainty Equivalent \\(CE\\). We expand this around \\(\\mu_W\\) as well. (This is valid assuming the risk premium is small, so \\(CE\\) is close to \\(\\mu_W\\)).\n\\[U(CE) \\approx U(\\mu_W) + U'(\\mu_W)(CE - \\mu_W)\\]\n(We stop at the first order here because \\(CE\\) is a deterministic constant, not a random variable, and we assume the difference \\((CE-\\mu_W)\\) is small enough that the squared term is negligible.)\nResult B: \\[U(CE) \\approx U(\\mu_W) + U'(\\mu_W)(CE - \\mu_W)\\]\n\n\nStep 4: Equating and Solving for CE\nRecall our definition: \\(U(CE) = E[U(W)]\\). Therefore, Result A = Result B.\n\\[U(\\mu_W) + U'(\\mu_W)(CE - \\mu_W) \\approx U(\\mu_W) + \\frac{1}{2}U''(\\mu_W)\\sigma^2_W\\]\nSubtract \\(U(\\mu_W)\\) from both sides:\n\\[U'(\\mu_W)(CE - \\mu_W) \\approx \\frac{1}{2}U''(\\mu_W)\\sigma^2_W\\]\nDivide by \\(U'(\\mu_W)\\) to isolate \\(CE\\):\n\\[CE - \\mu_W \\approx \\frac{1}{2} \\frac{U''(\\mu_W)}{U'(\\mu_W)} \\sigma^2_W\\]\n\\[CE \\approx \\mu_W + \\frac{1}{2} \\frac{U''(\\mu_W)}{U'(\\mu_W)} \\sigma^2_W\\]\n\n\nStep 5: Introducing the Risk Aversion Parameter\nWe substitute the Arrow-Pratt coefficient of absolute risk aversion, defined as \\(A = -\\frac{U''(\\mu_W)}{U'(\\mu_W)}\\).\n\\[CE \\approx \\mu_W - \\frac{1}{2} A \\sigma^2_W\\]\n\n\nStep 6: Converting Wealth to Portfolio Returns\nThe equation above is in terms of wealth. We must convert it to portfolio returns.\nLet \\(W_0\\) be initial wealth and \\(R_p\\) be the random portfolio return with mean \\(\\mu_p\\) and variance \\(\\sigma^2_p\\). Final wealth is: \\(W = W_0(1 + R_p)\\). We can compute the mean and variance of final wealth \\(W\\):\n\nMean: \\(\\mu_W = W_0(1 + \\mu_p) = W_0 + W_0 \\mu_p\\)\nVariance: \\(\\sigma^2_W = W_0^2 \\sigma^2_p\\)\n\nSubstitute these into the CE equation:\n\\[CE \\approx (W_0 + W_0 \\mu_p) - \\frac{1}{2} A (W_0^2 \\sigma^2_p)\\]\n\n\nStep 7: The Final Optimization\nThe investor wants to maximize \\(CE\\). In an optimization problem, we can remove additive constants (\\(W_0\\)) and divide by positive constants (\\(W_0\\)) without changing the location of the maximum.\n\nMaximize CE: \\[\\max \\left[ W_0 + W_0 \\mu_p - \\frac{1}{2} A W_0^2 \\sigma^2_p \\right]\\]\nRemove additive constant \\(W_0\\): \\[\\max \\left[ W_0 \\mu_p - \\frac{1}{2} A W_0^2 \\sigma^2_p \\right]\\]\nDivide by scaling factor \\(W_0\\): \\[\\max \\left[ \\mu_p - \\frac{1}{2} (A \\cdot W_0) \\sigma^2_p \\right]\\]\nDefine Relative Risk Aversion (\\(\\gamma\\)): We define \\(\\gamma = A \\cdot W_0\\). This is the coefficient of Relative Risk Aversion.\nSubstitute Vector Notation: \\(\\mu_p = \\mathbf{w}^T \\mathbf{\\mu}\\) and \\(\\sigma^2_p = \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}\\)\n\nWe arrive at the final optimization problem:\n\\[\\max_{\\mathbf{w}} \\quad \\mathbf{w}^T \\mathbf{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}\\]"
  },
  {
    "objectID": "option-bi-tree.html",
    "href": "option-bi-tree.html",
    "title": "Pricing Options Using Binomial Trees",
    "section": "",
    "text": "This tutorial demonstrates how to price European and American options using a binomial tree model in Python. The binomial tree model is a popular method for option pricing due to its simplicity and flexibility."
  },
  {
    "objectID": "option-bi-tree.html#introduction",
    "href": "option-bi-tree.html#introduction",
    "title": "Pricing Options Using Binomial Trees",
    "section": "",
    "text": "This tutorial demonstrates how to price European and American options using a binomial tree model in Python. The binomial tree model is a popular method for option pricing due to its simplicity and flexibility."
  },
  {
    "objectID": "option-bi-tree.html#recap-binomial-tree-model",
    "href": "option-bi-tree.html#recap-binomial-tree-model",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Recap: Binomial Tree Model",
    "text": "Recap: Binomial Tree Model\nThe binomial tree model is a discrete-time model for the evolution of an asset’s price. It assumes that, over each small time step, the asset price can move to one of two possible values: an “up” value or a “down” value. The model is built on the following parameters:\n\nCurrent stock price: \\(S_0\\)\nStrike price of the option: \\(K\\)\nTime to maturity (in years): \\(T\\)\nRisk-free interest rate (annualized): \\(r\\)\nVolatility of the underlying asset (annualized): \\(\\sigma\\)\nNumber of time steps in the binomial tree: \\(N\\)\n\nFrom these parameters, we can calculate the parameters needed for the binomial tree:\n\nLength of each time step: \\(\\Delta t = \\frac{T}{N}\\)\nUp factor: \\(u = e^{\\sigma \\sqrt{\\Delta t}}\\)\nDown factor: \\(d = 1/u\\)\nRisk-neutral probability of an up move: \\(p = \\frac{e^{r \\Delta t} - d}{u - d}\\)\n\nAsset prices at each node of the tree can be calculated as follows:\n\\[S_{j,i} = S_0 \\cdot u^{i-j} \\cdot d^{j},\\]\nwhere \\(i={0,1,2,...,N}\\) is the time step and \\(j={0,1,2,...,i}\\) is the number of down moves.1\n1 The notation and formula are chosen such that it matches the code implementation later.The value of options can be calculated using backward induction, starting from the terminal nodes (maturity) and working backward to the root node (current time).\nThe value of the option at end of the tree is determined by its payoff at maturity. For a call option, the payoff is given by (denote \\(f_{j, i}\\) as the option value at node \\(j\\) at time step \\(i\\)):\n\\[f_{j, N} = \\max(0, S_{j, N} - K)\\]\nFor a put option, the payoff is given by:\n\\[f_{j, N} = \\max(0, K - S_{j, N})\\]\nThe option value at each preceding node is calculated as the discounted expected value of the option at the next time step:\n\\[f_{j, i} = e^{-r \\Delta t} [p \\cdot f_{j, i+1} + (1 - p) \\cdot f_{j+1, i+1}]\\]\nFor American options, we also need to consider the possibility of early exercise at each node:\n\\[f_{j, i} = \\max(f_{j, i}, S_{j, i} - K)\\]\nFor a detailed explanation of the binomial tree model, please refer to Hull (2021) (chapter 13 and 21).\n\nHull, J. 2021. Options, Futures, and Other Derivatives. Business and Economics. Pearson. https://www-2.rotman.utoronto.ca/~hull/ofod/index.html."
  },
  {
    "objectID": "option-bi-tree.html#basic-algorithm",
    "href": "option-bi-tree.html#basic-algorithm",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Basic Algorithm",
    "text": "Basic Algorithm\nImplementing the binomial tree model involves the following steps:\n\nParameters: Define the parameters for the option and the underlying asset. Calculate the binomial tree parameters.\nTree Construction: Construct a binomial tree to store the possible future prices of the option and the underlying asset at each time step. In our implementation, we use 2D arrays to represent the binomial tree. Therefore, effectively, only the upper triangles of the arrays are used.2 We construct three 2D arrays: one for asset prices, one for option values, and one to track whether the option is exercised at each node.3\n\n2 For example, for a tree with \\(N=2\\), we create a 2D array with 3 rows and 3 columns to store option values. However, we really just need the upper triangle (including the diagonal) of the array to store the option values for all nodes:\nMatrix representation: \\[\n\\begin{bmatrix}\nf_{0,0} & f_{0,1} & f_{0,2} \\\\\n0 & f_{1,1} & f_{1,2} \\\\\n0 & 0 & f_{2,2}\n\\end{bmatrix}\n\\]3 We use 2D arrays mainly for clarity and visualization purpose. In practice, if intermediate results are not needed, we can optimize the memory usage by using 1D arrays, as shown later.\nAsset Price Calculation: Calculate the asset prices at each node of the tree using the up and down factors.\nOption Valuation: Calculate the option value at each node of the tree, starting from the terminal nodes (maturity) and working backward to the root node (current time). For European options, the option can only be exercised at maturity, while for American options, it can be exercised at any time before or at maturity."
  },
  {
    "objectID": "option-bi-tree.html#pricing-a-european-call-option",
    "href": "option-bi-tree.html#pricing-a-european-call-option",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Pricing a European Call Option",
    "text": "Pricing a European Call Option\nWe start by pricing a European call option using a binomial tree with 2 time steps.\n\nimport numpy as np\n\n# Parameters\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 2     # Number of time steps\n\n# Calculate parameters for the binomial tree\ndt = T / N  # Time step size\nu = np.exp(sigma * np.sqrt(dt))  # Up factor\nd = 1 / u  # Down factor\np = (np.exp(r * dt) - d) / (u - d)  # Risk-neutral probability\n\n# Initialize three 2D arrays to represent the binomial tree\n# One for asset prices, one for option values, and one to track exercises\nasset_prices = np.zeros((N + 1, N + 1))\noption_values = np.zeros((N + 1, N + 1))\nexercises = np.zeros((N + 1, N + 1), dtype=bool)\n\n# Set asset prices at each node\nfor i in range(N + 1):\n    for j in range(i + 1):\n        asset_prices[j, i] = S0 * (u ** (i - j)) * (d ** j)\n\n# Set option values at maturity\noption_values[:, N] = np.maximum(0, asset_prices[:, N] - K)\n\n# Set exercise values at maturity\nexercises[:, N] = (asset_prices[:, N] - K) &gt; 0\n\n# Backward induction to calculate option price at earlier nodes\nfor i in range(N - 1, -1, -1):\n    # Time step i\n\n    for j in range(i + 1):\n        # Update option values\n        option_values[j, i] = np.exp(-r * dt) * (p * option_values[j, i + 1] + (1 - p) * option_values[j + 1, i + 1])\n\n# Display parameters and option price\nprint(\"Strike Price:\", K)\nprint(f\"Time to Maturity (T): {T} year(s)\")\nprint(f\"Time Step (dt): {dt:.4f} year(s)\")\nprint(f\"Discount Factor per Step: {np.exp(-r * dt):.4f}\")\nprint(f\"Risk-neutral Probability (p): {p:.4f}\")\nprint(f\"Up Factor (u): {u:.4f}\")\nprint(f\"Down Factor (d): {d:.4f}\")\nprint()\nprint(f\"Option Price: {option_values[0, 0]:.4f}\")\n\nStrike Price: 100\nTime to Maturity (T): 1 year(s)\nTime Step (dt): 0.5000 year(s)\nDiscount Factor per Step: 0.9753\nRisk-neutral Probability (p): 0.5539\nUp Factor (u): 1.1519\nDown Factor (d): 0.8681\n\nOption Price: 9.5405\n\n\nWe can visualize the binomial tree structure and the option values at each node.\n\n\nDefine a function to plot the binomial tree (click to expand)\n# Plotting the Binomial Tree\nimport matplotlib.pyplot as plt\n\ndef plot_binomial_tree(asset_prices, option_values, exercises, N):\n    fig, ax = plt.subplots()\n    for i in range(N + 1):\n        for j in range(i + 1):\n            x = i  # Set x-coordinate based on time step\n            y = i - 2 * j  # Adjust y-coordinate for symmetry\n            \n            # Plot the node\n            if exercises[j, i]:\n                fcolor = 'lemonchiffon'  # Color for exercised nodes\n            else:\n                fcolor = 'white'  # Color for non-exercised nodes\n            \n            ax.text(x, y, \n                f\"S: {asset_prices[j, i]:.2f}\\nf: {option_values[j, i]:.2f}\", \n                ha='center', va='center', \n                bbox=dict(facecolor=fcolor, edgecolor='black'))\n            \n            # Draw branches\n            if i &lt; N:\n                ax.plot([x, x + 1], [y, y - 1], 'k-')  # Downward branch\n                ax.plot([x, x + 1], [y, y + 1], 'k-')  # Upward branch\n  \n    # Set limits and labels\n    ax.set_xlim(0, N)\n    ax.set_ylim(-N - 1, N + 1)\n    ax.set_xlabel('Time Steps')\n\n    # Set x-ticks (start from 0 and increment by 1)\n    ax.set_xticks(range(N + 1))\n    \n    # Remove unnecessary spines and ticks\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    ax.yaxis.set_visible(False)\n\n    ax.set_title('Binomial Tree for Option Pricing')\n\n    plt.show()\n\n\n\n# Plot the tree\nplot_binomial_tree(asset_prices, option_values, exercises, N)"
  },
  {
    "objectID": "option-bi-tree.html#pricing-a-american-put-option",
    "href": "option-bi-tree.html#pricing-a-american-put-option",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Pricing a American Put Option",
    "text": "Pricing a American Put Option\nThe process for pricing an American put option is similar, but we need to account for the possibility of early exercise at each node. (Three code changes are marked in the comments.)\n\nimport numpy as np\n\n# Parameters\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 4     # Number of time steps\n\n# Calculate parameters for the binomial tree\ndt = T / N  # Time step size\nu = np.exp(sigma * np.sqrt(dt))  # Up factor\nd = 1 / u  # Down factor\np = (np.exp(r * dt) - d) / (u - d)  # Risk-neutral probability\n\n# Initialize three 2D arrays to represent the binomial tree\n# One for asset prices, one for option values, and one to track exercises\nasset_prices = np.zeros((N + 1, N + 1))\noption_values = np.zeros((N + 1, N + 1))\nexercises = np.zeros((N + 1, N + 1), dtype=bool)\n\n# Set asset prices at each node\nfor i in range(N + 1):\n    for j in range(i + 1):\n        asset_prices[j, i] = S0 * (u ** (i - j)) * (d ** j)\n\n# Set option values at maturity (Change 1)\noption_values[:, N] = np.maximum(0, K - asset_prices[:, N])\n\n# Set exercise values at maturity (Change 2)\nexercises[:, N] = (K - asset_prices[:, N]) &gt; 0\n\n# Backward induction to calculate option price at earlier nodes\nfor i in range(N - 1, -1, -1):\n    # Time step i\n\n    for j in range(i + 1):\n        # Update option values\n        option_values[j, i] = np.exp(-r * dt) * (p * option_values[j, i + 1] + (1 - p) * option_values[j + 1, i + 1])\n\n        # Check for early exercise and update option values accordingly (Change 3)\n        exercises[j, i] = (K - asset_prices[j, i]) &gt; option_values[j, i]\n        option_values[j, i] = np.maximum(option_values[j, i], K - asset_prices[j, i])\n\n# Display parameters and option price\nprint(\"Strike Price:\", K)\nprint(f\"Time to Maturity (T): {T} year(s)\")\nprint(f\"Time Step (dt): {dt:.4f} year(s)\")\nprint(f\"Discount Factor per Step: {np.exp(-r * dt):.4f}\")\nprint(f\"Risk-neutral Probability (p): {p:.4f}\")\nprint(f\"Up Factor (u): {u:.4f}\")\nprint(f\"Down Factor (d): {d:.4f}\")\nprint()\nprint(f\"Option Price: {option_values[0, 0]:.4f}\")\n\nStrike Price: 100\nTime to Maturity (T): 1 year(s)\nTime Step (dt): 0.2500 year(s)\nDiscount Factor per Step: 0.9876\nRisk-neutral Probability (p): 0.5378\nUp Factor (u): 1.1052\nDown Factor (d): 0.9048\n\nOption Price: 5.8828\n\n\n\n# Plot the tree\nplot_binomial_tree(asset_prices, option_values, exercises, N)"
  },
  {
    "objectID": "option-bi-tree.html#putting-it-all-together-with-efficiency-improvements",
    "href": "option-bi-tree.html#putting-it-all-together-with-efficiency-improvements",
    "title": "Pricing Options Using Binomial Trees",
    "section": "Putting It All Together with Efficiency Improvements",
    "text": "Putting It All Together with Efficiency Improvements\nWe can encapsulate the binomial tree option pricing logic into a single function that can handle both European and American options, as well as call and put options.\nIn this implementation, we are not interested in storing the entire binomial tree structure for visualization purposes. On the other hand, we focus on optimizing the efficiency of the algorithm.\n\nSince during the backward induction process, we only need the current and next time step values, we can reduce the memory usage by using 1D arrays instead of 2D arrays.\nAt each time step, instead of looping through all nodes, we can use Numpy’s vectorized operations and array slicing to update only the relevant parts of the 1D arrays. NumPy’s internal optimizations make these operations faster than explicit Python loops.\n\nThese optimizations will be particularly useful when dealing with a large number of time steps.\n\nimport numpy as np\n\ndef binomial_tree(S0, K, T, r, sigma, N, call=True, american=False):\n    # Calculate parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n\n    # Initialize two 1D arrays to keep track of asset prices and option values\n    # These arrays will be updated in place during the backward induction at each time step\n    # Only the necessary parts of the arrays will be used when updating\n    S = np.zeros(N + 1)\n    f = np.zeros(N + 1)\n\n    # Set asset prices at maturity\n    # Note: since d = 1 / u, the calculation can be simplified\n    S = S0 * u ** np.arange(N, -N - 2, -2)\n\n    # Set option values at maturity\n    if call:\n        f = np.maximum(0, S - K)\n    else:\n        f = np.maximum(0, K - S)\n\n    # Backward induction to calculate option price at earlier nodes\n    for i in range(N - 1, -1, -1):\n        # Time step i\n        \n        # Only the first i+1 elements need to be updated at this step\n        last_idx = i + 1\n\n        # Update option values\n        f[:last_idx] = np.exp(-r * dt) * (p * f[:last_idx] + (1 - p) * f[1:last_idx + 1])\n        \n        # For American options, check for early exercise\n        if american:\n            # Update asset prices\n            S[:last_idx] = S0 * u ** np.arange(i, -i - 2, -2)\n            \n            # Check for early exercise and update option values accordingly\n            if call:\n                f[:last_idx] = np.maximum(f[:last_idx], S[:last_idx] - K)\n            else:\n                f[:last_idx] = np.maximum(f[:last_idx], K - S[:last_idx])\n\n    return f[0]\n\nLet’s apply this function using the same parameters as before.\n\n# European Call Option\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 2     # Number of time steps\ncall = True  # True for Call option, False for Put option\namerican = False  # True for American option, False for European\n\n# Calculate option price\noption_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"Option Price: {option_price:.4f}\")\n\nOption Price: 9.5405\n\n\n\n# American Put Option\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 4     # Number of time steps\ncall = False  # True for Call option, False for Put option\namerican = True  # True for American option, False for European\n\n# Calculate option price\noption_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"Option Price: {option_price:.4f}\")\n\nOption Price: 5.8828\n\n\nNote that the results match those obtained from the previous implementations.\nFinally, let’s use a larger number of time steps to get more accurate results.\n\n# European Call Option\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nT = 1     # Time to maturity in years\nr = 0.05  # Risk-free interest rate\nsigma = 0.2  # Volatility\nN = 15000    # Number of time steps\ncall = True  # True for Call option, False for Put option\namerican = False  # True for American option, False for European\n\n# Calculate option price\nec_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"European Call Option Price: {ec_price:.4f}\")\n\n# American Put Option\ncall = False  # True for Call option, False for Put option\namerican = True  # True for American option, False for European\n\n# Calculate option price\nap_price = binomial_tree(S0, K, T, r, sigma, N, call, american)\nprint(f\"American Put Option Price: {ap_price:.4f}\")\n\nEuropean Call Option Price: 10.4505\nAmerican Put Option Price: 6.0903\n\n\nSince Black-Scholes formula can be used for pricing European options, we can compare the European call option price with the Black-Scholes price.\n\nfrom scipy.stats import norm\n\ndef black_scholes_european_call(S0, K, T, r, sigma):\n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n\n# Calculate Black-Scholes price for European call option\nbs_price = black_scholes_european_call(S0, K, T, r, sigma)\nprint(f\"Black-Scholes European Call Option Price: {bs_price:.4f}\")\n\nBlack-Scholes European Call Option Price: 10.4506\n\n\nWe see the European call option price from the binomial tree model is very close to the Black-Scholes price."
  },
  {
    "objectID": "option-bi-tree.html#references",
    "href": "option-bi-tree.html#references",
    "title": "Pricing Options Using Binomial Trees",
    "section": "References",
    "text": "References\nHull, J. C. (2021). Options, Futures, and Other Derivatives (11th ed.). Pearson."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Finance with Python - A Few Examples",
    "section": "",
    "text": "Simulating Stock Price Path with GBM\nPricing Options with a Binomial Tree\nDelta Hedging a European Call Option\nMean-Variance Portfolio Optimization"
  },
  {
    "objectID": "delta-hedging.html",
    "href": "delta-hedging.html",
    "title": "Delta Hedging a European Call Option",
    "section": "",
    "text": "Delta hedging is a fundamental strategy in options trading that aims to reduce the directional risk associated with price fluctuations in the underlying asset. By dynamically adjusting their holdings in the underlying asset, traders can maintain a delta-neutral portfolio, thereby mitigating potential losses from price movements.\nIn this tutorial, we demonstrate how to implement a delta hedging strategy for a European call option using Python. We simulate the underlying stock price using Geometric Brownian Motion (GBM), compute the option’s delta via the Black–Scholes model, and periodically adjust the hedge at a specified rebalancing frequency."
  },
  {
    "objectID": "delta-hedging.html#introduction",
    "href": "delta-hedging.html#introduction",
    "title": "Delta Hedging a European Call Option",
    "section": "",
    "text": "Delta hedging is a fundamental strategy in options trading that aims to reduce the directional risk associated with price fluctuations in the underlying asset. By dynamically adjusting their holdings in the underlying asset, traders can maintain a delta-neutral portfolio, thereby mitigating potential losses from price movements.\nIn this tutorial, we demonstrate how to implement a delta hedging strategy for a European call option using Python. We simulate the underlying stock price using Geometric Brownian Motion (GBM), compute the option’s delta via the Black–Scholes model, and periodically adjust the hedge at a specified rebalancing frequency."
  },
  {
    "objectID": "delta-hedging.html#recap-of-key-concepts",
    "href": "delta-hedging.html#recap-of-key-concepts",
    "title": "Delta Hedging a European Call Option",
    "section": "Recap of Key Concepts",
    "text": "Recap of Key Concepts\nBefore we get into the implementation, let’s briefly revisit some key concepts behind delta hedging.\n\nDelta and BS Delta\nThe Delta (\\(\\Delta\\)) of an option measures the sensitivity of an option’s price to changes in the price of the underlying asset. For a call option, delta ranges from 0 to 1, indicating how much the option price is expected to change for a small change in the underlying asset’s price. For example, a delta of 0.6 means that for a small increase in the underlying asset’s price, the option price is expected to increase by approximately 60% of that change.\nThe Black-Scholes model is a mathematical model used to price European options and calculate their Greeks, including delta. Under the Black-Scholes framework, the price of a European call option (on a non-dividend-paying stock) with stock price \\(S\\), strike price \\(K\\), time to expiration \\(T\\), risk-free interest rate \\(r\\), and volatility \\(\\sigma\\) is given by:\n\\[C(S, K, T, r, \\sigma) = S N(d_1) - K e^{-rT} N(d_2),\\]\nwhere \\[d_1 = \\frac{\\ln(S / K) + (r + \\sigma^2 / 2) T}{\\sigma \\sqrt{T}},\\] \\[d_2 = d_1 - \\sigma \\sqrt{T},\\] and \\(N(\\cdot)\\) is the cumulative distribution function of the standard normal distribution.\nThe Black-Scholes delta (BS delta) of a European call option can be calculated as follows:\n\\[\\Delta(\\text{Call}) = \\frac{\\partial C}{\\partial S} = N(d_1)\\]\nNote that at expiration (\\(T=0\\)), the delta of a call option is \\(1\\) if the option is in-the-money (\\(S &gt; K\\)) and \\(0\\) if it is out-of-the-money (\\(S \\leq K\\)).\n\n\nDelta Hedging\nThe Delta hedging strategy involves taking a position in the underlying asset that offsets the delta of the option position.\nFor example, if you sold a call option on \\(100\\) shares of a stock and the option’s BS delta is \\(0.6\\), you would buy \\(0.6 \\times 100 = 60\\) shares of the stock to hedge your position. This hedge operation is known as delta neutralization. A short position in a call option with 100 shares means the total delta on the option is \\(0.6 \\times (-100) = -600.\\) The delta of one share of a stock is \\(1\\), so by buying \\(600\\) shares of the stock, you neutralize the delta of the option position. Since delta changes as the underlying asset price changes, to keep a delta neutral position, the hedge must be adjusted continuously.\nFormally, to hedge a short position in a call option (with a standard contract size of 100 shares of the underlying stock), you hold \\(100\\Delta\\) units of the underlying stock.1 Therefore, the value of your hedging portfolio at time \\(t\\) is:\n1 Conversely, to hedge a long position in a call option, you hold \\(-100\\Delta\\) units of the underlying stock.\\[\nV_t^{\\text{hedge}} = 100 \\Delta_t S_t + B_t,\n\\]\nwhere \\(100 \\Delta_t S_t\\) is the value of the stock position, and \\(B_t\\) is the value of the cash or bond position. A negative \\(B_t\\) indicates a borrowing position.\nDefine\n\\[\nB_0 = V_0^{\\text{opt}} - 100\\Delta_0 S_0,\n\\tag{1}\\]\nwhere \\(V_0^{\\text{opt}}\\) is the initial option value at time \\(0\\), which is the option price calculated using the Black-Scholes formula, and \\(100\\Delta_0 S_0\\) is the cost of purchasing the initial hedge position in the underlying stock. In this setup, we assume the option is sold at time \\(0\\) at its theoretical price, and the premium received from selling the option is included in the initial cash position \\(B_0\\).\nFurther, suppose that we re-balance at \\(\\Delta t\\) intervals. The cash position \\(B_t\\) then evolves over time as follows: \\[\nB_t = B_{t-1}e^{r\\Delta t} - 100(\\Delta_t - \\Delta_{t-1})S_t,\n\\tag{2}\\] where \\(r\\) is the risk-free interest rate. The first term on the right-hand side represents the growth of the cash position due to interest, while the second term represents the cost (or proceeds) from adjusting the stock position to maintain delta neutrality.\nIf the hedge is perfect (i.e., \\(\\Delta t \\to 0\\)), this portfolio replicates the option’s price path: \\[\nV_t^{\\text{hedge}} = V_t^{\\text{opt}}\n\\] for all \\(t\\).\nFor discrete rebalancing, there are replication errors. In particular, at expiration \\(T\\), the replication error is given by: \\[\n\\begin{align*}\n    \\varepsilon_T &= V_T^{\\text{hedge}} - V_T^{\\text{opt}} \\\\\n    &= 100 \\Delta_T S_T + B_T - 100\\max(S_T - K, 0) \\\\\n    &= \\begin{cases}\n            B_T + K  & \\text{if } S_T &gt; K \\\\\n            B_T      & \\text{if } S_T \\leq K\n        \\end{cases}\n\\end{align*}\n\\tag{3}\\]\nAgain, if the hedge is perfect, then \\(\\varepsilon_T = 0\\), but with discrete rebalancing, \\(\\varepsilon_T\\) will generally be non-zero and can be positive (a profit) or negative (a loss). The expected value of \\(\\varepsilon_T\\) is typically negative, reflecting the cost of hedging.2\n2 If the model is mis-specified (e.g., the true volatility is lower than the assumed volatility), the expected replication error can be positive.One commonly used metric to measure hedging performance is the ratio of the standard deviation of the replication error \\(\\varepsilon_T\\) (discounted to \\(t=0\\)) to the option’s theoretical price \\(V_0^{\\text{opt}}\\). Define \\(\\tilde{\\varepsilon}_T := e^{-rT} \\varepsilon_T.\\) The hedging performance is then given by: \\[\n\\frac{\\text{sd}(\\tilde{\\varepsilon}_T)}{V_0^{\\text{opt}}}\n\\]\nThis measure scales the disperse of replication error by the option price, providing a normalized measure of hedging effectiveness. It allows meaningful comparison of hedge performance across options with different strikes, maturities, volatilities, or underlyings with different price levels.3\n3 Note that to measure hedging performance, we care about the dispersion of the replication error, not its expected value. The dispersion captures how much residual risk (unhedged randomness) remains after hedging. On the other hand, the expected value of the replication error captures systematic bias of hedging (i.e., on average over/under hedging).\n\nAn Alternative Formulation\nThe above formulation of delta hedging start by setting up a hedging portfolio that replicates the option’s price at \\(t=0\\). That is, the initial cash position \\(B_0\\) includes the premium received from selling the option (see Equation 1) so that the total value of the hedging portfolio equals the option price at \\(t=0\\).\nAn alternative approach is to start with \\[\nB_0 = - 100\\Delta_0 S_0\n\\]\nThe initial value of the hedging portfolio is now zero, i.e., \\(V_0^{\\text{hedge}} = 0.\\)\nThe evolution of \\(B_t\\) is still given by Equation 2. The negative of the cash position (i.e., \\(-B_t\\)) now represents the cumulative cost of hedging up to time \\(t\\) (excluding the initial option premium received).\nIf the hedging is perfect, \\(V_t^{\\text{hedge}} = 0\\) for all \\(t\\), but this is of course not possible with discrete rebalancing.\nAt expiration, the replication error at expiration is again given by Equation 3. However, the interpretation of the replication error is now different. The replication error (\\(-\\varepsilon_T\\), to be more precise) now captures the total cost of hedging, excluding the initial option premium received.\nUnder perfect hedging, the replication error (again \\(-\\varepsilon_T\\) to be precise) is equal to the option payoff (i.e., the total cost of hedging equals the option payoff). This also means that the expected value of the replication error (\\(-E[\\varepsilon_T]\\)) discounted to \\(t=0\\) is equal to the theoretical price of the option.\nWith discrete rebalancing, the replication error (\\(-\\varepsilon_T\\)) will generally be different from the option payoff. The expected value of the replication error (\\(-E[\\varepsilon_T]\\)) discounted to \\(t=0\\) is typically more than the theoretical price of the option, reflecting the cost of hedging."
  },
  {
    "objectID": "delta-hedging.html#scenario-setup",
    "href": "delta-hedging.html#scenario-setup",
    "title": "Delta Hedging a European Call Option",
    "section": "Scenario Setup",
    "text": "Scenario Setup\nWe use the same setup as in Hull (2021) (chapter 19) to illustrate the delta hedging strategy. We assume a financial institution has sold a European call option on \\(100,000\\) shares of a non-dividend-paying stock and wants to hedge its position using delta hedging. The institution will adjust its hedge position weekly over a 20-week period until the option expires.\nWe will consider the following parameters for our simulation:\n\nInitial stock price: \\(S_0 = 49\\)\nStrike price: \\(K = 50\\)\nTime to expiration: \\(T = 0.3846\\) years (20 weeks)\nRisk-free interest rate: \\(r = 5\\%\\)\nVolatility (per annum): \\(\\sigma = 20\\%\\)\n\nWe also assume the option is sold at its theoretical price although this is not essential for our implementation and analysis."
  },
  {
    "objectID": "delta-hedging.html#a-step-by-step-implementation",
    "href": "delta-hedging.html#a-step-by-step-implementation",
    "title": "Delta Hedging a European Call Option",
    "section": "A Step-by-Step Implementation",
    "text": "A Step-by-Step Implementation\nIn this implementation, we simulate a single stock price path using Geometric Brownian Motion (GBM) and perform delta hedging step by step within a for loop.4 At each iteration, we record all relevant results to prepare for a tabular presentation. To maintain readability and ensure numerical consistency in the table, we round the values to appropriate decimal places.\n4 Later, when we investigate the relationship between hedging performance and rebalancing frequencies, we will eliminate the for loop and re-implement delta hedging with vectorized code to improve efficiency.We apply the alternative formulation discussed earlier to track the delta hedging process, i.e., setting \\(B_0 = - 100\\Delta_0 S_0\\). This approach ensures consistency with the table presentation in Hull (2021) (Chapter 19). With this formulation, the cumulative hedging cost is \\(-B_t\\), the negative of the cash position. The final hedging cost, excluding the initial option premium received, is given by \\(- \\varepsilon_T\\), the negative of the replication error.\nWe start by implementing the stock price simulation function simulate_gbm_path(). This implementation is explained in details in the GBM simulation tutorial.\n\n\nStock Price Simulation with GBM (click to expand)\nimport numpy as np\n\n# --- GBM simulation ---\ndef simulate_gbm_path(S0, mu, sigma, T, N, num_path, seed=None):\n\n    if seed is not None:\n        np.random.seed(seed)\n    \n    dt = T / N # Time step size\n    t = np.linspace(0, T, N+1) # Time grid; N+1 points to include t=0\n\n    # Generate all the standard normal shocks at once for all paths\n    eps = np.random.normal(size=(num_path, N))\n    \n    # Generate the Brownian motion paths; add W(0) = 0\n    W = np.cumsum(np.sqrt(dt) * eps, axis=1)\n    W = np.concatenate((np.zeros((num_path, 1)), W), axis=1)\n\n    # Calculate log-prices using vectorized operations\n    log_S = np.log(S0) + (mu - 0.5 * sigma**2) * t + sigma * W\n\n    # Exponentiate to get stock prices\n    return np.exp(log_S)\n\n\nNext we define a function to calculate the Black-Scholes delta.\n\nimport numpy as np\nfrom scipy.stats import norm\n\n# --- Black-Scholes delta ---\ndef calculate_bs_delta(S, K, T, r, sigma):\n    \n    # At expiration, delta is 1 if in-the-money, else 0\n    # Check this before d1 calculation to avoid division by zero\n    if T &lt;= 0:\n        return 1.0 if S &gt; K else 0.0\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n\n    return norm.cdf(d1)\n\nWe now implement the delta hedging logic step by step.\n\n# --- Delta Hedging Implementation ---\n# Parameters\nS0 = 49          # Initial stock price\nK = 50           # Strike price\nT = 20 / 52      # Time to expiration in years (20 weeks)\nr = 0.05         # Risk-free interest rate\nsigma = 0.2      # Volatility (20% per annum)\n\ncontract_size = 100000  # Number of shares per option contract\n\n# Simulation parameters\nN = 20           # Number of time steps (weekly rebalancing)\nnum_path = 1     # Number of simulated paths\n\n# Simulate stock price path\nS = simulate_gbm_path(S0, r, sigma, T, N, num_path, seed=37)\nS = S[0].round(2)  # Use the first (and only) path and round to 2 decimal places\n\n# Initialize arrays for delta hedging\ndelta = np.zeros(N + 1)\nshare_purchased = np.zeros(N + 1)\nshare_in_hand = np.zeros(N + 1)\ncost_of_share_purchased = np.zeros(N + 1)\ncost_of_interest = np.zeros(N + 1)\ncumulative_cost = np.zeros(N + 1)\n\n# Time to expiration at each step\nT_t = np.linspace(T, 0, N + 1)\n\n# Time step size\ndt = T / N\n\n# Initial hedge setup at t=0\ndelta[0] = round(calculate_bs_delta(S[0], K, T, r, sigma), 3)\nshare_purchased[0] = delta[0] * contract_size\nshare_in_hand[0] = share_purchased[0]\ncost_of_share_purchased[0] = round(share_purchased[0] * S[0] / 1000, 1)\ncumulative_cost[0] = cost_of_share_purchased[0]\ncost_of_interest[0] = round(cumulative_cost[0] * (np.exp(r * dt) - 1), 1)\n\n# Delta hedging over time\nfor i in range(1, N + 1):\n    delta[i] = round(calculate_bs_delta(S[i], K, T_t[i], r, sigma), 3)\n    delta_change = delta[i] - delta[i - 1]\n    share_purchased[i] = delta_change * contract_size\n    share_in_hand[i] = share_in_hand[i-1] + share_purchased[i]\n    cost_of_share_purchased[i] = round(share_purchased[i] * S[i] / 1000, 1)\n    cumulative_cost[i] = cumulative_cost[i-1] + cost_of_share_purchased[i] + cost_of_interest[i-1]\n    cost_of_interest[i] = round(cumulative_cost[i] * (np.exp(r * dt) - 1), 1)\n\ncost_of_interest[20] = np.nan  # No interest cost at maturity\n\n# Final stock price and shares held\nfinal_price  = S[-1]\nfinal_shares = share_in_hand[-1]\n\n# Option payoff at maturity\npayoff = max(final_price - K, 0) * contract_size / 1000\n\n# Stock value at maturity\nstock_value = final_price * final_shares / 1000\n\n# Value of hedging portfolio\nhedge_portfolio_value = stock_value - cumulative_cost[-1]\n\n# Final hedging cost\nhedging_cost = payoff - hedge_portfolio_value\n\n# Print results\nprint(f\"Final stock price: {final_price:.2f}\")\nprint(f\"Option payoff ($000): {payoff:.2f}\")\nprint(f\"Hedge portfolio value ($000): {hedge_portfolio_value:.2f}\")\nprint(f\"Final hedging cost ($000): {hedging_cost:.2f}\")\n\nFinal stock price: 62.41\nOption payoff ($000): 1241.00\nHedge portfolio value ($000): 1019.90\nFinal hedging cost ($000): 221.10\n\n\nWe now present the step-by-step delta hedging strategy in a well-formatted table (with the help of the Python great_tables library).\n\n\nDisplay step-by-step delta hedging (click to expand)\nimport pandas as pd\nfrom great_tables import GT, html\n\n# Create a DataFrame for printing results\ndf = pd.DataFrame({\n    \"week\": np.arange(N + 1),\n    \"stock_price\": S,\n    \"delta\": delta,\n    \"share_purchased\": share_purchased,\n    \"share_in_hand\": share_in_hand,\n    \"cost_of_share_purchased\": cost_of_share_purchased,\n    \"cumulative_cost\": cumulative_cost,\n    \"cost_of_interest\": cost_of_interest\n})\n\nfrom great_tables import GT, html\n\ngt_table = (\n    GT(df)\n    .fmt_integer(columns=[\"share_purchased\", \"share_in_hand\"],\n                 accounting=True)\n    .fmt_number(columns=[\"stock_price\"], decimals=2)\n    .fmt_number(columns=[\"delta\"], decimals=3)\n    .fmt_number(columns=[\"cost_of_share_purchased\", \"cumulative_cost\", \"cost_of_interest\"], \n                decimals=1,\n                accounting=True)\n    .tab_header(\n        title=\"Simulation of Delta Hedging\",\n        subtitle=\"(Weekly Rebalancing for a European Call Option on 100,000 Shares)\"\n    )\n    .cols_label(\n        week=\"Week\",\n        stock_price=html(\"Stock &lt;br&gt; price\"),\n        delta=\"Delta\",\n        share_purchased=html(\"Shares &lt;br&gt; purchased\"),\n        share_in_hand=html(\"Shares &lt;br&gt; in portfolio\"),\n        cost_of_share_purchased=html(\"Cost of shares &lt;br&gt; purchased &lt;br&gt; ($000)\"),\n        cumulative_cost=html(\"Cumulative cost &lt;br&gt; including interest &lt;br&gt; ($000)\"),\n        cost_of_interest=html(\"Interest &lt;br&gt; cost &lt;br&gt; ($000)\")\n    )\n    .cols_align(align=\"center\")\n)\n\ngt_table.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulation of Delta Hedging\n\n\n(Weekly Rebalancing for a European Call Option on 100,000 Shares)\n\n\nWeek\nStock\nprice\nDelta\nShares\npurchased\nShares\nin portfolio\nCost of shares\npurchased\n($000)\nCumulative cost\nincluding interest\n($000)\nInterest\ncost\n($000)\n\n\n\n\n0\n49.00\n0.522\n52,200\n52,200\n2,557.8\n2,557.8\n2.5\n\n\n1\n48.95\n0.514\n(800)\n51,400\n(39.2)\n2,521.1\n2.4\n\n\n2\n49.91\n0.576\n6,200\n57,600\n309.4\n2,832.9\n2.7\n\n\n3\n50.42\n0.608\n3,200\n60,800\n161.3\n2,996.9\n2.9\n\n\n4\n48.66\n0.480\n(12,800)\n48,000\n(622.8)\n2,377.0\n2.3\n\n\n5\n50.78\n0.630\n15,000\n63,000\n761.7\n3,141.0\n3.0\n\n\n6\n52.23\n0.726\n9,600\n72,600\n501.4\n3,645.4\n3.5\n\n\n7\n52.66\n0.756\n3,000\n75,600\n158.0\n3,806.9\n3.7\n\n\n8\n52.04\n0.721\n(3,500)\n72,100\n(182.1)\n3,628.5\n3.5\n\n\n9\n53.48\n0.814\n9,300\n81,400\n497.4\n4,129.4\n4.0\n\n\n10\n52.29\n0.747\n(6,700)\n74,700\n(350.3)\n3,783.1\n3.6\n\n\n11\n53.11\n0.808\n6,100\n80,800\n324.0\n4,110.7\n4.0\n\n\n12\n54.98\n0.911\n10,300\n91,100\n566.3\n4,681.0\n4.5\n\n\n13\n55.81\n0.948\n3,700\n94,800\n206.5\n4,892.0\n4.7\n\n\n14\n55.74\n0.957\n900\n95,700\n50.2\n4,946.9\n4.8\n\n\n15\n55.72\n0.968\n1,100\n96,800\n61.3\n5,013.0\n4.8\n\n\n16\n55.82\n0.981\n1,300\n98,100\n72.6\n5,090.4\n4.9\n\n\n17\n58.14\n0.999\n1,800\n99,900\n104.7\n5,200.0\n5.0\n\n\n18\n61.32\n1.000\n100\n100,000\n6.1\n5,211.1\n5.0\n\n\n19\n62.04\n1.000\n0\n100,000\n0.0\n5,216.1\n5.0\n\n\n20\n62.41\n1.000\n0\n100,000\n0.0\n5,221.1\n\n\n\n\n\n\n\n\n\nIn this simulation, the initial stock price is \\(\\$49\\), and the initial BS delta is \\(0.522\\). Accordingly, \\(0.522 \\times 100,000 = 52,200\\) shares must be purchased to establish the initial hedge portfolio. The cost of acquiring these shares is \\(\\$49 \\times 52,200 = \\$2,557.8K\\). Since there is no interest cost at \\(t=0\\), the cumulative cost at this point is also \\(\\$2,557.8K\\).\nAt the end of week 1, the interest cost amounts to \\(\\$2,557.8K \\times (e^{0.05 \\times 1/52} - 1) \\approx \\$2.5K\\). This is added to the cumulative cost, along with the cost (or proceeds) from rebalancing the hedge. In our case, since the delta decreases from \\(0.522\\) to \\(0.514\\), a change of \\(0.008\\), the portfolio sells \\(0.008 \\times 100,000 = 800\\) shares at \\(\\$48.95\\) per each to maintain neutrality, producing a cash inflow of approximately \\(\\$39.2K\\). Thus, the cumulative cost at the end of week 1 becomes \\(\\$2,557.8K - \\$39.2K + \\$2.5K = \\$2,521.1K\\).\nAt expiration, the option closes in-the-money, resulting in a positive option payoff. The final hedging cost of \\(\\$221.1K\\) is the cumulative rebalancing cost \\(\\$5,221.1K\\) minus the \\(\\$5\\) million received from the option holder at expiration (i.e., the \\(100,000\\) shares at the option seller’s hedging portfolio is paid at the predetermined strike price of \\(\\$50\\)).\nEquivalently, the final hedging cost can also be computed as the negative of the replication error (\\(-\\varepsilon_T\\)), which equals the difference between the option payoff and the value of the hedging portfolio at expiration. The option payoff is \\((\\$62.41 - \\$50) \\times 100,000\\), corresponding to exercising the option to purchase \\(100,000\\) shares at the strike price of \\(\\$50\\) when the stock price is \\(\\$62.41\\) at expiration. The value of the hedging portfolio equals the stock position value \\(\\$62.41 \\times 100,000\\) minus the cumulative hedging cost of \\(\\$5,221.1K\\).\nNext, we generate a different stock price path where the option expires out of the money to examine how the delta hedging strategy performs in this scenario.5 Below we present the results.\n5 The random seed used to generate this stock price path is 42.\n\nFinal stock price: 45.08\nOption payoff ($000): 0.00\nHedge portfolio value ($000): -238.80\nFinal hedging cost ($000): 238.80\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulation of Delta Hedging\n\n\n(Weekly Rebalancing for a European Call Option on 100,000 Shares)\n\n\nWeek\nStock\nprice\nDelta\nShares\npurchased\nShares\nin portfolio\nCost of shares\npurchased\n($000)\nCumulative cost\nincluding interest\n($000)\nInterest\ncost\n($000)\n\n\n\n\n0\n49.00\n0.522\n52,200\n52,200\n2,557.8\n2,557.8\n2.5\n\n\n1\n49.71\n0.565\n4,300\n56,500\n213.8\n2,774.1\n2.7\n\n\n2\n49.55\n0.551\n(1,400)\n55,100\n(69.4)\n2,707.4\n2.6\n\n\n3\n50.47\n0.611\n6,000\n61,100\n302.8\n3,012.8\n2.9\n\n\n4\n52.68\n0.747\n13,600\n74,700\n716.4\n3,732.1\n3.6\n\n\n5\n52.37\n0.732\n(1,500)\n73,200\n(78.6)\n3,657.1\n3.5\n\n\n6\n52.06\n0.716\n(1,600)\n71,600\n(83.3)\n3,577.3\n3.4\n\n\n7\n54.42\n0.847\n13,100\n84,700\n712.9\n4,293.6\n4.1\n\n\n8\n55.63\n0.899\n5,200\n89,900\n289.3\n4,587.0\n4.4\n\n\n9\n54.94\n0.882\n(1,700)\n88,200\n(93.4)\n4,498.0\n4.3\n\n\n10\n55.80\n0.920\n3,800\n92,000\n212.0\n4,714.3\n4.5\n\n\n11\n55.12\n0.906\n(1,400)\n90,600\n(77.2)\n4,641.6\n4.5\n\n\n12\n54.45\n0.890\n(1,600)\n89,000\n(87.1)\n4,559.0\n4.4\n\n\n13\n54.85\n0.918\n2,800\n91,800\n153.6\n4,717.0\n4.5\n\n\n14\n52.04\n0.760\n(15,800)\n76,000\n(822.2)\n3,899.3\n3.8\n\n\n15\n49.64\n0.497\n(26,300)\n49,700\n(1,305.5)\n2,597.6\n2.5\n\n\n16\n48.90\n0.381\n(11,600)\n38,100\n(567.2)\n2,032.9\n2.0\n\n\n17\n47.57\n0.170\n(21,100)\n17,000\n(1,003.7)\n1,031.2\n1.0\n\n\n18\n48.02\n0.168\n(200)\n16,800\n(9.6)\n1,022.6\n1.0\n\n\n19\n46.85\n0.011\n(15,700)\n1,100\n(735.5)\n288.1\n0.3\n\n\n20\n45.08\n0.000\n(1,100)\n0\n(49.6)\n238.8\n\n\n\n\n\n\n\n\n\nSince the initial condition is the same as before, the hedging portfolio is established in exactly the same way. By the end of week 1, the stock price rises, leading to an increase in the option’s delta. Accordingly, additional shares are purchased to rebalance the hedge.\nAt the end of week 20, the stock price falls to \\(\\$45.08\\), and the option expires out of the money with a payoff of zero. The final hedging cost is therefore the cumulative cost of rebalancing the hedge over the 20 weeks. This amounts to \\(\\$238.8K\\).\nSimilarly, the final hedging cost can be calculated as the negative of the replication error (\\(-\\varepsilon_T\\)). In this case, the option payoff is zero. The value of the hedging portfolio is given by the value of the stock position, which is zero as no stocks are held at the end of week 20, minus the cumulative hedging cost of \\(\\$238.8K\\). The final hedging cost is therefore \\(0 - (\\$0 - \\$238.8K) = \\$238.8K\\)."
  },
  {
    "objectID": "delta-hedging.html#a-vectorized-implementation",
    "href": "delta-hedging.html#a-vectorized-implementation",
    "title": "Delta Hedging a European Call Option",
    "section": "A Vectorized Implementation",
    "text": "A Vectorized Implementation\nTo enhance computational efficiency, especially when performing delta hedging on multiple simulated stock price paths, we can implement the delta hedging strategy using vectorized operations with Python’s NumPy library. This approach eliminates the need for explicit loops, enabling more efficient handling of large-scale simulations.\nSince our stock price path simulation function, simulate_gbm_path(), is already vectorized to support multiple paths, we begin by defining a vectorized version of the Black–Scholes delta function capable of processing arrays of stock prices and times to expiration.\n\n# ndtr from scipy.special is faster than norm.cdf from scipy.stats\nfrom scipy.special import ndtr\n\n# --- Black-Scholes delta (vectorized) ---\n1def calculate_bs_delta(S, K, T, r, sigma):\n    # Avoid division by zero inside sqrt\n    eps = 1e-12\n    t_safe = np.maximum(T, eps)\n\n    # Use t_safe in both numerator and denominator for consistency\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * t_safe) / (\n        sigma * np.sqrt(t_safe)\n    )\n\n    # Use scipy's ndtr for fast cumulative normal distribution calculation\n    delta = ndtr(d1)\n\n    # At expiration: delta = 1 if S &gt; K else 0\n    delta = np.where(T &lt;= 0, (S &gt; K).astype(float), delta)\n\n    return delta\n\n\n1\n\nThis function can handle array inputs for S and T, returning an array of delta values. In the code below when the function is called, the shape of S is (num_path, N+1), and the shape of T is (N+1,). Broadcasting rules in NumPy will ensure that the operations are performed correctly across these dimensions. The returned delta will have the shape (num_path, N+1).\n\n\n\n\nNext, we implement the delta hedging logic in a vectorized manner. This function simulates multiple stock price paths and calculates the hedging costs for all paths at once.\n\n# --- Delta Hedging (Vectorized) ---\ndef delta_hedge(S0, K, T, r, sigma, contract_size, N, num_path, seed=None):\n    \n    # Simulate stock price paths; shape: (num_path, N+1)\n    S = simulate_gbm_path(S0, r, sigma, T, N, num_path, seed=seed)  \n\n    # Time to expiration at each step; shape: (N+1,)\n    T_t = np.linspace(T, 0, N + 1)\n\n    # Calculate interest factors for cash account; shape : (N+1,)\n    interest_factor = np.exp(r * T_t)\n\n    # Calculate deltas and changes in deltas; shape: (num_path, N+1)\n    delta = calculate_bs_delta(S, K, T_t, r, sigma)\n    delta_change = np.diff(delta, axis=1, prepend=0)\n\n    # Cost of purchasing shares at each step; shape: (num_path, N+1)\n    cost_of_share_purchased = (delta_change * contract_size * S)\n\n    # Cumulative cost adjusted for interest; shape: (num_path,)\n    cumulative_cost = np.sum(cost_of_share_purchased * interest_factor, axis=1)\n\n    # Option payoff at maturity; shape: (num_path,)\n    payoff = np.maximum(S[:,-1] - K, 0) * contract_size\n\n    # hedge portfolio value at maturity; shape: (num_path,)\n    hedge_portfolio_value = S[:,-1] * (delta[:,-1] * contract_size) - cumulative_cost\n\n    # Final hedging cost (rebalancing costs + replication error); shape: (num_path,)\n    hedging_cost = payoff - hedge_portfolio_value\n\n    return hedging_cost\n\nWe run two tests to verify the correctness of our vectorized implementation. Both tests use the same parameters as before (including the same random seeds), and both will simulate two paths. Generating two paths allows us to confirm that the function handles multiple paths correctly. We compare the hedging cost of the first path in each test against the results from our earlier step-by-step implementation.\n\n# Parameters\nS0 = 49          # Initial stock price\nK = 50           # Strike price\nT = 20 / 52      # Time to expiration in years (20 weeks)\nr = 0.05         # Risk-free interest rate\nsigma = 0.2      # Volatility (20% per annum)\n\ncontract_size = 100_000  # Number of shares per option contract\n\n# Simulation parameters\nN = 20           # Number of time steps (weekly rebalancing)\nnum_path = 2     # Number of simulated paths\n\n# Run the vectorized delta hedging function\nresults_seed37 = delta_hedge(S0, K, T, r, sigma, contract_size, N, num_path, seed=37)\nresults_seed42 = delta_hedge(S0, K, T, r, sigma, contract_size, N, num_path, seed=42)\n\n# Print the average hedging cost\nprint(\"Final hedging cost ($000; seed 37):\",\n      np.array2string(results_seed37/1000, precision=2, separator=', '))\nprint(\"Final hedging cost ($000; seed 42):\",\n      np.array2string(results_seed42/1000, precision=2, separator=', '))\n\nFinal hedging cost ($000; seed 37): [220.51, 257.92]\nFinal hedging cost ($000; seed 42): [238.62, 234.82]\n\n\nIn the first test (seed 37), we expect the hedging cost of the first path to be approximately \\(\\$221.10\\) (in 000s), and we get \\(220.51\\). In the second test (seed 42), we expect the hedging cost of the first path to be about \\(\\$238.80\\) (in 000s), and we get \\(238.62\\). The results confirm that the hedging cost of the first path in each test closely matches the outcome from our step-by-step implementation, with only minor discrepancies attributable to rounding errors in the step-by-step approach. The second path in each test is newly generated so it yields different hedging costs.\nWe are now prepared to analyze the hedging performance across various rebalancing frequencies. Following the approach in Hull (2021) (Chapter 19), we consider rebalancing intervals ranging from once every five weeks to four times per week. For each frequency, we simulate \\(1,000,000\\) stock price paths and evaluate the hedging performance by calculating the standard deviation of the hedging cost relative to the theoretical option price.\n\nHull, J. 2021. Options, Futures, and Other Derivatives. Business and Economics. Pearson. https://www-2.rotman.utoronto.ca/~hull/ofod/index.html.\n\n# Black-Scholes formula to calculate the theoretical option price\ndef calculate_bs_call_price(S0, K, T, r, sigma):\n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    call_price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return call_price\n\n# Parameters\nS0 = 49          # Initial stock price\nK = 50           # Strike price\nT = 20 / 52      # Time to expiration in years (20 weeks)\nr = 0.05         # Risk-free interest rate\nsigma = 0.2      # Volatility (20% per annum)\n\ncontract_size = 100_000  # Number of shares per option contract\n\noption_price = calculate_bs_call_price(S0, K, T, r, sigma) * contract_size\nprint(f\"Theoretical option price ($000): {option_price/1000:.2f}\")\n\n# Simulation parameters\nN = 20           # Number of time steps (weekly rebalancing)\nnum_path = 1_000_000     # Number of simulated paths\n\n# Run delta hedging for different rebalancing frequencies\nfrequencies = [5, 4, 2, 1, 0.5, 0.25]  # in weeks\nresults = {}\nfor freq in frequencies:\n    N_steps = int(N / freq)  # Convert frequency in weeks to number of steps\n    hedging_costs = delta_hedge(S0, K, T, r, sigma, contract_size, N_steps, num_path, seed=42)\n    results[freq] = hedging_costs\n\n# Display the result in a simple table\nprint(\"\\nHedging Performance for Different Rebalancing Frequencies:\")\nprint(\"-\" * 60)\nprint(\"Frequency | Mean Cost | Std Dev  | Hedging Performance\")\nprint(\" (weeks)  |  ($000)   |  ($000)  | (Std Dev / Option Price)\")\nprint(\"-\" * 60)\nfor freq, costs in results.items():\n    cost_time_0 = costs * np.exp(-r * T)  # Adjust cost to time 0 value\n    mean_cost = np.mean(cost_time_0) / 1000  # Convert to 000s\n    std_cost = np.std(cost_time_0) / 1000  # Convert to 000s\n    hedging_performance = std_cost / (option_price / 1000)  # Ratio of std to option price\n    print(f\"   {freq:.2f}   |  {mean_cost:.2f}   |  {std_cost:5.2f}   |  {hedging_performance:.2f}\")\n\nTheoretical option price ($000): 240.05\n\nHedging Performance for Different Rebalancing Frequencies:\n------------------------------------------------------------\nFrequency | Mean Cost | Std Dev  | Hedging Performance\n (weeks)  |  ($000)   |  ($000)  | (Std Dev / Option Price)\n------------------------------------------------------------\n   5.00   |  240.16   |  98.38   |  0.41\n   4.00   |  240.18   |  88.82   |  0.37\n   2.00   |  240.08   |  64.17   |  0.27\n   1.00   |  240.09   |  46.08   |  0.19\n   0.50   |  240.04   |  33.01   |  0.14\n   0.25   |  240.07   |  23.52   |  0.10\n\n\nAs expected, the average hedging cost across all simulated paths is slightly larger than the theoretical option price. Increasing the rebalancing frequency brings the average hedging cost closer to the theoretical value. Nevertheless, with discrete rebalancing, replication error will always remain.\nOn the other hand, hedging performance improves as the rebalancing frequency increases. More frequent adjustments allow for better alignment with the option’s delta, thereby reducing overall risk."
  },
  {
    "objectID": "delta-hedging.html#references",
    "href": "delta-hedging.html#references",
    "title": "Delta Hedging a European Call Option",
    "section": "References",
    "text": "References\nHull, J. C. (2021). Options, Futures, and Other Derivatives (11th ed.). Pearson."
  },
  {
    "objectID": "mvp.html",
    "href": "mvp.html",
    "title": "Mean Variance Portfolio Optimization",
    "section": "",
    "text": "Mean variance portfolio theory (MPT) is a mathematical framework for constructing a portfolio of assets optimally balancing expected return and risk. The theory was introduced by Markowitz (1952) in his seminal 1952 paper “Portfolio Selection,” which laid the foundation for modern portfolio theory.\n\nMarkowitz, Harry. 1952. “Portfolio Selection.” The Journal of Finance 7 (1): 77–91. http://www.jstor.org/stable/2975974.\nIn this tutorial, we implement the classic mean-variance portfolio optimization problem using Python. We use historical stock price data to estimate the expected returns and covariance matrix of a set of assets, and then use these estimates to construct an optimal portfolio."
  },
  {
    "objectID": "mvp.html#intoduction",
    "href": "mvp.html#intoduction",
    "title": "Mean Variance Portfolio Optimization",
    "section": "",
    "text": "Mean variance portfolio theory (MPT) is a mathematical framework for constructing a portfolio of assets optimally balancing expected return and risk. The theory was introduced by Markowitz (1952) in his seminal 1952 paper “Portfolio Selection,” which laid the foundation for modern portfolio theory.\n\nMarkowitz, Harry. 1952. “Portfolio Selection.” The Journal of Finance 7 (1): 77–91. http://www.jstor.org/stable/2975974.\nIn this tutorial, we implement the classic mean-variance portfolio optimization problem using Python. We use historical stock price data to estimate the expected returns and covariance matrix of a set of assets, and then use these estimates to construct an optimal portfolio."
  },
  {
    "objectID": "mvp.html#recap-of-key-concepts",
    "href": "mvp.html#recap-of-key-concepts",
    "title": "Mean Variance Portfolio Optimization",
    "section": "Recap of Key Concepts",
    "text": "Recap of Key Concepts\n\nFormulation\nLet’s consider a portfolio of \\(n\\) risky assets. Let\n\n\\(\\mathbf{w} = (w_1, w_2, \\ldots, w_n)^T\\) be the vector of portfolio weights, where \\(w_i\\) is the proportion of the total portfolio value invested in asset \\(i\\).\n\\(\\mathbf{\\mu} = (\\mu_1, \\mu_2, \\ldots, \\mu_n)^T\\) be the vector of expected returns for each asset.\n\\(\\mathbf{\\Sigma} = (\\sigma_{ij})_{n \\times n}\\) be the \\(n \\times n\\) covariance matrix of asset returns.\n\\(\\mathbf{1}\\) be a vector of ones of length \\(n\\).\n\nThe mean-variance optimization problem can be formulated as the following maximization problem:\n\\[\\begin{aligned}\n\\max_{\\mathbf{w}} \\quad & \\mathbf{w}^T \\mathbf{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w} \\\\\n\\text{s.t} \\quad & \\mathbf{1}^T \\mathbf{w} = 1, \\\\\n\\end{aligned}\\]\nwhere \\(\\gamma &gt; 0\\) is the risk aversion parameter.\nThe first term in the objective function represents the expected return of the portfolio, while the second term represents the risk (variance) of the portfolio, scaled by the risk aversion parameter. The constraint ensures that the total weight of the portfolio sums to 1 1.\n1 There are other equivalent formulations of the mean-variance optimization problem, such as minimizing portfolio variance subject to a lower bound on expected return or maximizing expected return subject to an upper bound on level of variance.\n\\[\n\\begin{aligned}\n\\min_{\\mathbf{w}} \\quad & \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w} \\\\\n\\text{s.t} \\quad & \\mathbf{w}^T \\mathbf{\\mu} \\geq \\mu_p, \\mathbf{1}^T \\mathbf{w} = 1\\\\\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n\\max_{\\mathbf{w}} \\quad & \\mathbf{w}^T \\mathbf{\\mu} \\\\\n\\text{s.t} \\quad & \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w} \\leq \\sigma_p^2, \\mathbf{1}^T \\mathbf{w} = 1\\\\\n\\end{aligned}\n\\]\nSee here for a discussion on three equivalent formulations of the mean-variance optimization problem.This mean-variance objective function for an investor can be justified in a few ways. One common justification is that investors are assumed to be rational and risk-averse, meaning they prefer higher returns and lower risk. The mean-variance objective captures this trade-off between return and risk, allowing investors to make decisions based on their individual risk preferences.\nYou may recall that a rational investor maximizes their expected utility. Isn’t it possible to directly maximize the expected utility instead of using the mean-variance objective? Yes, it is possible. However, the mean-variance objective is often used as an approximation of the expected utility maximization problem. This is because the mean-variance objective is easier to compute and analyze than the expected utility function, especially when dealing with multiple assets.\n(For more on mean-variance approximation of expected utility, see Levy and Markowitz (1979). There is a large literature on this topic. For example, see some recent discussions in Markowitz (2014) and Schuhmacher, Kohrs, and Auer (2021). See also the appendix for linking the mean-variance objective to expected utility maximization using a Taylor expansion.)\n\nLevy, H., and H. M. Markowitz. 1979. “Approximating Expected Utility by a Function of Mean and Variance.” The American Economic Review 69 (3): 308–17. http://www.jstor.org/stable/1807366.\n\n———. 2014. “Mean-Variance Approximations to Expected Utility.” European Journal of Operational Research 234 (2): 346–55. https://doi.org/10.1016/j.ejor.2012.08.023.\n\nSchuhmacher, Frank, Hendrik Kohrs, and Benjamin R. Auer. 2021. “Justifying Mean-Variance Portfolio Selection When Asset Returns Are Skewed.” Management Science 67 (12): 7812–24. https://doi.org/10.1287/mnsc.2020.3846.\n\n\nSolving the Optimization Problem\nTo solve the mean-variance optimization problem, we can use various optimization techniques, such as quadratic programming (as we have a quadratic objective function and a linear constraint) or the method of Lagrange multipliers.\nFor the current setup, we can find a closed-form solution to the mean-variance optimization problem using the method of Lagrange multipliers. The Lagrangian function for this problem is given by:\n\\[\\mathcal{L}(\\mathbf{w}, \\lambda) = \\mathbf{w}^T \\mathbf{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w} + \\lambda (1 - \\mathbf{1}^T \\mathbf{w}),\\]\nwhere \\(\\lambda\\) is the Lagrange multiplier associated with the constraint.\nTo find the optimal portfolio weights, we take the partial derivatives of the Lagrangian with respect to \\(\\mathbf{w}\\) and \\(\\lambda\\), set them to zero, and solve the resulting system of equations. Setting the derivatives to zero gives us the following equations2:\n2 Recall that, from Matrix Calculus,\n\\[\\frac{\\partial}{\\partial \\mathbf{w}} (\\mathbf{w}^T \\mathbf{\\mu}) = \\mathbf{\\mu},\\]\n\\[\\frac{\\partial}{\\partial \\mathbf{w}} (\\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}) = 2\\mathbf{\\Sigma}\\mathbf{w}\\]\n(since \\(\\mathbf{\\Sigma}\\) is a symmetric), and\n\\[\\frac{\\partial}{\\partial \\mathbf{w}} (\\lambda \\mathbf{1}^T \\mathbf{w}) = \\lambda \\mathbf{1}.\\]\\[\\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{w}} = \\mathbf{\\mu} - \\gamma \\mathbf{\\Sigma} \\mathbf{w} - \\lambda \\mathbf{1} = 0 \\tag{1}\\]\n\\[\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = 1 - \\mathbf{1}^T \\mathbf{w} = 0 \\tag{2}\\]\nAssuming \\(\\mathbf{\\Sigma}\\) is positive definite, and hence invertible, we solve for \\(\\mathbf{w}\\) using Equation 1:\n\\[\\mathbf{w} = \\frac{1}{\\gamma} \\mathbf{\\Sigma}^{-1} (\\mathbf{\\mu} - \\lambda \\mathbf{1})\\]\nPlug the result into Equation 2 to solve for \\(\\lambda\\).\n\\[\n\\lambda = \\frac{\\mathbf{1}^T \\mathbf{\\Sigma}^{-1} \\mathbf{\\mu} - \\gamma}{\\mathbf{1}^T \\mathbf{\\Sigma}^{-1} \\mathbf{1}}\n\\]\nTo make the notation cleaner, let’s define two scalars:\n\n\\(A = \\mathbf{1}^T \\mathbf{\\Sigma}^{-1} \\mathbf{1}\\)\n\\(B = \\mathbf{1}^T \\mathbf{\\Sigma}^{-1} \\mathbf{\\mu}\\)\n\nThus, \\[\n\\lambda = \\frac{B - \\gamma}{A}\n\\]\nSubstituting \\(\\lambda\\) back into the expression for \\(\\mathbf{w}\\), we obtain the optimal portfolio weights:\n\\[\n\\mathbf{w}^* = \\frac{1}{\\gamma} \\mathbf{\\Sigma}^{-1} \\left( \\mathbf{\\mu} - \\frac{B - \\gamma}{A} \\mathbf{1} \\right)\n\\]\nOr, grouping terms by \\(\\gamma\\),\n\\[\n\\mathbf{w}^* = \\frac{1}{A} \\mathbf{\\Sigma}^{-1} \\mathbf{1} + \\frac{1}{\\gamma} \\left( \\mathbf{\\Sigma}^{-1} \\mathbf{\\mu} - \\frac{B}{A} \\mathbf{\\Sigma}^{-1} \\mathbf{1} \\right)\n\\]\nNote that the first order condition is both necessary and sufficient for optimality since the objective function is concave (the negative of a convex quadratic function) and the constraint is linear.\nAs \\(\\gamma \\to \\infty\\), the investor becomes infinitely risk-averse and the optimal portfolio converges to the minimum variance portfolio:\n\\[\\mathbf{w}_{MVP} = \\frac{1}{A} \\mathbf{\\Sigma}^{-1} \\mathbf{1}.\\]\nTo trace out the efficient frontier, the set of optimal portfolios for different levels of risk aversion, we can vary \\(\\gamma\\) from a small value (close to risk-neutral) to a large value (more risk-averse) and compute the corresponding optimal portfolio weights.\nIn the the risk-return plane (portfolio standard deviation vs expected return), the efficient frontier is the upper portion of the hyperbola formed by these optimal portfolios. That is, let \\(\\mu_p = \\mathbf{w}^{*T} \\mathbf{\\mu}\\) be the expected return of the optimal portfolio, and \\(\\sigma_p = \\sqrt{\\mathbf{w}^{*T} \\mathbf{\\Sigma} \\mathbf{w}^*}\\) be the standard deviation (risk) of the optimal portfolio. By varying \\(\\gamma\\), we can plot \\(\\mu_p\\) against \\(\\sigma_p\\) to visualize the efficient frontier.\nIn particular, let’s define another scalar \\(C=\\mu^T \\mathbf{\\Sigma}^{-1} \\mathbf{\\mu}\\). We then have:\n\\[\n\\mu_p = \\frac{B}{A} + \\frac{1}{\\gamma} \\left( C - \\frac{B^2}{A} \\right)\n\\]\n\\[\n\\sigma_p^2 = \\frac{1}{A} + \\frac{1}{\\gamma^2} \\left( C - \\frac{B^2}{A} \\right)\n\\]\nIn the Python implementation below, we actually trace out the efficient frontier by varying the expected return \\(\\mu_p\\). \\(\\mu_p\\) starts from the expected return associated with the minimum variance portfolio (\\(\\mu_p \\geq\\frac{B}{A}\\)). For any given \\(\\mu_p\\), we can solve for \\(\\sigma_p\\) as\n\\[\n\\sigma_p = \\sqrt{\\frac{A\\mu_p^2 - 2B\\mu_p + C}{AC-B^2}}.\n\\]\n\n\nRisk-free Asset Extension\nWe can extend the mean-variance optimization problem to include a risk-free asset with return \\(r_f\\). Let \\(w_f\\) be the weight of the risk-free asset in the portfolio, and \\(\\mathbf{w}\\) be the weights of the risky assets. The new optimization problem becomes:\n\\[\n\\begin{aligned}\n\\max_{\\mathbf{w}, w_f} \\quad & \\mathbf{w}^T \\mathbf{\\mu} + w_f r_f - \\frac{\\gamma}{2} \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w} \\\\\n\\text{s.t} \\quad & \\mathbf{1}^T \\mathbf{w} + w_f = 1 \\\\\n\\end{aligned}\n\\]\nNote that the risk-free asset does not contribute to the portfolio variance.\nThe solution to this problem can be derived similarly using the method of Lagrange multipliers, leading to adjusted optimal weights for both risky and risk-free assets.\n\\[\\mathbf{w}^* = \\frac{1}{\\gamma} \\mathbf{\\Sigma}^{-1} \\underbrace{(\\mathbf{\\mu} - r_f \\mathbf{1})}_{\\text{Excess Returns}} \\tag{3}\\] \\[w_f^* = 1 - \\mathbf{1}^T \\mathbf{w}^* \\tag{4}\\]\nThe presence of a risk-free asset allows investors to achieve any desired combination of risk and return by adjusting the weights between the risk-free asset and the optimal risky portfolio. This leads to the concept of the Capital Market Line (CML), which represents the set of optimal portfolios that can be formed by combining the risk-free asset with the market portfolio of risky assets.\nThe CML is a straight line in the risk-return space, starting from the risk-free rate on the y-axis and tangent to the efficient frontier of risky assets. The tangency point represents the market portfolio, which is the optimal risky portfolio. The slope of the CML is given by the Sharpe ratio of the market portfolio, which measures the excess return per unit of risk.\nThe equation of the CML can be expressed as: \\[\n\\mu_p = r_f + \\frac{\\mu_m - r_f}{\\sigma_m} \\sigma_p\n\\] where \\(\\mu_p\\) and \\(\\sigma_p\\) are the expected return and standard deviation of the portfolio, \\(r_f\\) is the risk-free rate, and \\(\\mu_m\\) and \\(\\sigma_m\\) are the expected return and standard deviation of the market portfolio (i.e., the tangent portfolio).\nThe tangent portfolio can be derived by setting \\(w_f^*=0\\) becaueuse it lies on the efficient frontier of risky assets. This implies \\(\\mathbf{1}^T \\mathbf{w}_{tangent} = 1\\) (Equation 4), and hence the weights of the tangent portfolio are given by Equation 3 with \\(\\gamma\\) eliminated through normalization.\n\\[\n\\mathbf{w}_{tangent} = \\frac{\\mathbf{\\Sigma}^{-1}(\\mathbf{\\mu} - r_f \\mathbf{1})}{\\mathbf{1}^T \\mathbf{\\Sigma}^{-1} (\\mathbf{\\mu} - r_f \\mathbf{1})}\n\\]\n(Alternatively, the tangent portfolio can be found by maximizing the Sharpe ratio: \\[\n\\text{Sharpe Ratio} = \\frac{\\mathbf{w}^T (\\mathbf{\\mu} - r_f \\mathbf{1})}{\\sqrt{\\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}}},\n\\]\nwhich yields the same result.)\n\n\nFurther Constraint on Weights\nIn practice, investors often impose additional constraints on portfolio weights, such as prohibiting short-selling (i.e., \\(w_i \\geq 0\\) for all \\(i\\)) or setting upper bounds on individual asset allocations. These constraints can be incorporated into the optimization problem, but they also increase its complexity, making closed-form solutions unavailable in most cases. Consequently, such constrained optimization problems typically require numerical methods, as demonstrated in the Python implementation below."
  },
  {
    "objectID": "mvp.html#python-implementation-finally",
    "href": "mvp.html#python-implementation-finally",
    "title": "Mean Variance Portfolio Optimization",
    "section": "Python Implementation (Finally!)",
    "text": "Python Implementation (Finally!)\nWe implement the mean-variance portfolio optimization in Python using historical stock price data. We use the yfinance library to fetch stock data, numpy and pandas for data manipulation, and matplotlib for visualization.\n\nCase 1: Short Sell Allowed\nWe start by downloading the data and processing it to compute monthly returns, mean returns, and the covariance matrix. We also obtain the current risk-free rate from the 10-year Treasury yield, and then de-annualize it to a monthly rate.\n\nimport yfinance as yf\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# ------------------------------------------------------------------------------\n# 1. Data Acquisition and Processing\n# ------------------------------------------------------------------------------\n# 10 Well-known tickers and a risk-free asset\ntickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'NVDA', 'JPM', 'JNJ', 'PG', 'XOM', 'TSLA']\nrisk_free_ticker = \"^TNX\"  # 10 Year Treasury Note Yield\n\nprint(\"Downloading data...\")\n# Download past 5 years of data\ndata = yf.download(tickers, start=\"2020-10-01\", end=\"2025-10-31\", \n                   auto_adjust=False, progress=False)['Adj Close']\n\n# Resample to Monthly Returns\n# 'ME' is Month End\nmonthly_prices = data.resample('ME').last()\nmonthly_returns = monthly_prices.pct_change().dropna()\n\n# Calculate Mean Vector (mu) and Covariance Matrix (Sigma)\nmu = monthly_returns.mean()\nSigma = monthly_returns.cov()\n\n# Get the current Risk-Free Rate\n# ^TNX is in percentage (e.g., 4.5 for 4.5%). We divide by 100 for decimal.\n# Then de-annualize to monthly: (1 + r_annual)^(1/12) - 1\nrf_data = yf.download(risk_free_ticker, start=\"2025-10-30\", end=\"2025-10-31\", \n                      auto_adjust=False, progress=False)['Adj Close']\ncurrent_rf_annual = rf_data.iloc[-1].item() / 100\nrf = (1 + current_rf_annual)**(1/12) - 1\n\nprint(f\"Risk-Free Rate (Monthly): {rf:.4%}\")\n\nDownloading data...\nRisk-Free Rate (Monthly): 0.3348%\n\n\nWe then compute the optimal portfolio weights for both the minimum variance portfolio (MVP) and the tangency portfolio (with risk-free asset). We also derive the efficient frontier and the capital market line (CML) for visualization.\n\n# ------------------------------------------------------------------------------\n# 2. Analytical Solutions (Matrix Algebra)\n# ------------------------------------------------------------------------------\nnum_assets = len(tickers)\nones = np.ones(num_assets)\nSigma_inv = np.linalg.inv(Sigma)\n\n# --- Helper Constants for the Efficient Frontier ---\n# These constants define the hyperbola of the efficient frontier\nA = ones.T @ Sigma_inv @ ones\nB = ones.T @ Sigma_inv @ mu\nC = mu.T @ Sigma_inv @ mu\nDelta = A*C - B**2\n\n# --- Case 1: Risky Assets Only (Minimum Variance Portfolio) ---\n# Derived Formula: w_gmv = (Sigma_inv * 1) / A\nw_gmv = (Sigma_inv @ ones) / A\nmu_gmv = w_gmv @ mu\nsigma_gmv = np.sqrt(w_gmv @ Sigma @ w_gmv)\n\n# --- Case 2: With Risk-Free Asset (Tangency Portfolio) ---\n# Derived Formula: w_tan = Sigma_inv * (mu - rf*1) / normalized\nexcess_return_vector = mu - rf * ones\nZ = Sigma_inv @ excess_return_vector\nw_tan = Z / Z.sum() # Normalize so weights sum to 1\n\nmu_tan = w_tan @ mu\nsigma_tan = np.sqrt(w_tan @ Sigma @ w_tan)\n\n# Calculate Sharpe Ratio of Tangency Portfolio\nsharpe_ratio = (mu_tan - rf) / sigma_tan\n\n# ------------------------------------------------------------------------------\n# 3. Constructing the Curves for Plotting\n# ------------------------------------------------------------------------------\n\n# A. The Efficient Frontier (Hyperbola)\n# We generate a range of target returns (y-axis) to calculate minimal risk (x-axis)\ntarget_mus = np.linspace(mu_gmv - 0.01, mu_tan + 0.02, 100)\n# Formula: sigma^2 = (A*mu^2 - 2*B*mu + C) / Delta\ntarget_sigmas = np.sqrt((A * target_mus**2 - 2 * B * target_mus + C) / Delta)\n\n# B. The Capital Market Line (CML)\n# Line equation: y = rf + Sharpe * x\n# We create a range of risks (x-axis) starting from 0\ncml_x = np.linspace(0, sigma_tan + 0.05, 100)\ncml_y = rf + sharpe_ratio * cml_x\n\nWe now visualize the results, plotting individual assets, the efficient frontier, the minimum variance portfolio, the tangency portfolio, and the capital market line.\n\n# ------------------------------------------------------------------------------\n# 4. Visualization\n# ------------------------------------------------------------------------------\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# 1. Plot Individual Assets\nasset_vols = np.sqrt(np.diag(Sigma))\nax.scatter(asset_vols, mu, c='gray', alpha=0.6, label='Individual Assets')\nfor i, txt in enumerate(tickers):\n    ax.annotate(txt, (asset_vols[i], mu.iloc[i]), \n                xytext=(5,5), textcoords='offset points', fontsize=8)\n\n# 2. Plot Efficient Frontier (Risky Assets Only)\nax.plot(target_sigmas, target_mus, 'b-', linewidth=2, label='Efficient Frontier (Risky Only)')\n\n# 3. Plot Minimum Variance Portfolio\nax.scatter(sigma_gmv, mu_gmv, color='r', marker='*', \n           s=100, zorder=5, label='Global Min Variance (GMV)')\n\n# 4. Plot Tangency Portfolio\nax.scatter(sigma_tan, mu_tan, color='gold', marker='X', \n           s=100, edgecolors='black', zorder=5, label='Tangency Portfolio (Max Sharpe)')\n\n# 5. Plot Capital Market Line (CML)\nax.plot(cml_x, cml_y, 'g--', linewidth=2, \n        label=f'Capital Market Line (Sharpe: {sharpe_ratio:.2f})')\n\n# 6. Plot Risk-Free Rate\nax.scatter(0, rf, color='green', s=80, label=f'Risk-Free Rate: {rf:.2%}/mo')\n\n# Formatting\nax.figure.suptitle('Mean-Variance Optimization & Capital Market Line', fontsize=16)\nax.set_xlabel('Monthly Volatility (Standard Deviation)', fontsize=12)\nax.set_ylabel('Expected Monthly Return', fontsize=12)\nax.legend(loc='upper left', fontsize=10, frameon=True)\nax.grid(True, alpha=0.3)\nax.set_xlim(0, max(asset_vols) + 0.02)\n\nfig.text(0.96, 0.12, 'Data: 5 Years Monthly Returns (Yahoo Finance)',\n         fontsize=10,\n         color='gray',\n         horizontalalignment='right',\n         verticalalignment='bottom')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFinally, we output the optimal weights for both the minimum variance portfolio and the tangency portfolio, along with the maximum Sharpe ratio.\n\n# ------------------------------------------------------------------------------\n# 5. Output Weights\n# ------------------------------------------------------------------------------\nresults_df = pd.DataFrame({\n    'Asset': tickers,\n    'GMV Weights': np.round(w_gmv, 4),\n    'Tangency Weights': np.round(w_tan, 4)\n})\nprint(\"\\n--- Optimization Results ---\")\nprint(results_df.sort_values(by='Tangency Weights', ascending=False))\nprint(f\"\\nMax Sharpe Ratio: {sharpe_ratio:.4f}\")\n\n\n--- Optimization Results ---\n  Asset  GMV Weights  Tangency Weights\n6   JNJ      -0.0486            0.6723\n9  TSLA       0.1277            0.6380\n2  GOOG       0.1101            0.4728\n3  AMZN       0.3599            0.2070\n8   XOM       0.0056            0.1936\n5   JPM       0.0571            0.0153\n4  NVDA      -0.0333           -0.0356\n7    PG       0.3175           -0.0814\n0  AAPL      -0.0846           -0.0951\n1  MSFT       0.1886           -0.9871\n\nMax Sharpe Ratio: 0.5787\n\n\n\n\nCase 2: No Short Selling\nWe can modify the optimization problem to include non-negativity constraints on the portfolio weights, ensuring that no short-selling is allowed. In this case, no closed-form solution exists, but we can solve the problem using numerical optimization techniques.\nIn this implementation, we use the scipy.optimize.minimize function as our solver to find the optimal weights for both the minimum variance portfolio and the tangency portfolio under the no short-selling constraint. The objective functions are defined to minimize portfolio volatility and maximize the Sharpe ratio, respectively. In addition, we generate the constrained efficient frontier by minimizing volatility for a range of target returns subject to the no short-selling constraint 3.\n3 We use the Sequential Least Squares Programming (SLSQP) algorithm provided by scipy.optimize.minimize to handle the equality and inequality constraints along with bounds on the weights. See the SLSQP documentation for more details.The minimization objective (portfolio volatility) used in this case is equivalent to the maximization formulation used for the case without short selling constraint.\n\n# ------------------------------------------------------------------------------\n# 6. No Short Selling (Numerical Solution)\n# ------------------------------------------------------------------------------\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\n\nprint(\"\\nCalculating Constrained Optimization (No Short Selling)...\")\n\n# Objective Functions for Solver (a minimizer)\ndef portfolio_stats(weights, mu, Sigma):\n    w = np.array(weights)\n    ret = np.sum(w * mu)\n    vol = np.sqrt(np.dot(w.T, np.dot(Sigma, w)))\n    return ret, vol\n\ndef min_volatility(weights, mu, Sigma):\n    return portfolio_stats(weights, mu, Sigma)[1]\n\ndef neg_sharpe_ratio(weights, mu, Sigma, rf):\n    ret, vol = portfolio_stats(weights, mu, Sigma)\n    return -(ret - rf) / vol\n\n# Constraints & Bounds and Initial Guess\ncons_sum = {'type': 'eq', 'fun': lambda w: np.sum(w) - 1} # Sum(w) = 1\nbounds = tuple((0, np.inf) for _ in range(num_assets))  # 0 &lt;= w (No Short Selling)\ninit_guess = num_assets * [1. / num_assets]\n\n# 1. Find Constrained GMV\nopt_gmv_c = minimize(min_volatility, init_guess, args=(mu, Sigma), \n                     method='SLSQP', bounds=bounds, constraints=[cons_sum])\nw_gmv_c = opt_gmv_c.x\nret_gmv_c, vol_gmv_c = portfolio_stats(w_gmv_c, mu, Sigma)\n\n# 2. Find Constrained Tangency (Max Sharpe)\nopt_tan_c = minimize(neg_sharpe_ratio, init_guess, args=(mu, Sigma, rf), \n                     method='SLSQP', bounds=bounds, constraints=[cons_sum])\nw_tan_c = opt_tan_c.x\nret_tan_c, vol_tan_c = portfolio_stats(w_tan_c, mu, Sigma)\nsharpe_c = (ret_tan_c - rf) / vol_tan_c\n\n# 3. Generate Constrained Efficient Frontier\n# We minimize volatility for a range of specific target returns\ntarget_rets_c = np.linspace(ret_gmv_c, mu.max(), 50)\nfrontier_vols_c = []\nfrontier_rets_c = []\n\nfor tr in target_rets_c:\n    cons_ret = {'type': 'ineq', 'fun': lambda w: np.sum(w * mu) - tr} # Sum(w*mu) &gt;= tr\n    res = minimize(min_volatility, init_guess, args=(mu, Sigma), \n                   method='SLSQP', bounds=bounds, constraints=[cons_sum, cons_ret])\n    if res.success:\n        frontier_vols_c.append(res.fun)\n        frontier_rets_c.append(tr)\n\n# 4. Constrained CML\ncml_x_c = np.linspace(0, vol_tan_c + 0.05, 100)\ncml_y_c = rf + sharpe_c * cml_x_c\n\n\nCalculating Constrained Optimization (No Short Selling)...\n\n\nWe visualize the constrained optimization results, plotting the constrained efficient frontier and the constrained capital market line (CML).\n\n# ------------------------------------------------------------------------------\n# 7. Visualization B: No Short Selling\n# ------------------------------------------------------------------------------\nfig2, ax2 = plt.subplots(figsize=(8, 6))\n\n# Plot Elements\nax2.scatter(asset_vols, mu, c='gray', alpha=0.6, label='Individual Assets')\nfor i, txt in enumerate(tickers):\n    ax2.annotate(txt, (asset_vols[i], mu.iloc[i]), xytext=(5,5), \n                 textcoords='offset points', fontsize=8)\n\n# Plot Constrained Frontier\nax2.plot(frontier_vols_c, frontier_rets_c, 'b-', linewidth=2, \n         label='Efficient Frontier (No Short)')\n\n# Plot Constrained GMV\nax2.scatter(vol_gmv_c, ret_gmv_c, color='r', marker='*', \n            s=100, zorder=5, label='GMV (No Short)')\n\n# Plot Constrained Tangency\nax2.scatter(vol_tan_c, ret_tan_c, color='gold', marker='X', \n            s=100, edgecolors='black', zorder=5, label=f'Tangency (Sharpe: {sharpe_c:.2f})')\n# Plot Constrained CML\nax2.plot(cml_x_c, cml_y_c, 'r:', linewidth=2, label='Capital Market Line (Constrained)')\n\n# Plot Risk-Free Rate\nax2.scatter(0, rf, color='green', s=80, label=f'Risk-Free Rate: {rf:.2%}/mo')\n\nax2.set_title('Mean-Variance Optimization (NO SHORT SELLING)', fontsize=16)\nax2.set_xlabel('Monthly Volatility (Standard Deviation)', fontsize=12)\nax2.set_ylabel('Expected Monthly Return', fontsize=12)\nax2.legend(loc='upper left')\nax2.grid(True, alpha=0.3)\nax2.set_xlim(0, max(asset_vols) + 0.02)\n\nfig2.text(0.96, 0.12, 'Data: 5 Years Monthly Returns (Yahoo Finance)',\n         fontsize=10, color='gray', ha='right', va='bottom')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFinally, we compare the optimal weights for the Tangency Portfolio from both the unconstrained and constrained cases. We also report the maximum Sharpe ratios for both scenarios.\n\n# ------------------------------------------------------------------------------\n# 8. Compare Weights and Max Sharpe Ratios\n# ------------------------------------------------------------------------------\ncomparison_df = pd.DataFrame({\n    'Asset': tickers,\n    'Short Selling OK': np.round(w_tan, 4),\n    'No Short Selling': np.round(w_tan_c, 4)\n})\n\nprint(\"\\n--- Tangency Portfolio Weight Comparison ---\")\n# Filter to show only assets that have significant weight in at least one portfolio\nnumeric_cols = comparison_df.select_dtypes(include=[np.number])\nmask = (numeric_cols.abs() &gt; 0.001).any(axis=1)\nprint(comparison_df[mask].sort_values(by='No Short Selling', ascending=False))\n\nprint(f\"\\nMax Sharpe Ratio (Short Selling OK): {sharpe_ratio:.4f}\")\nprint(f\"Max Sharpe Ratio (No Short Selling): {sharpe_c:.4f}\")\n\n\n--- Tangency Portfolio Weight Comparison ---\n  Asset  Short Selling OK  No Short Selling\n9  TSLA            0.6380            0.4197\n6   JNJ            0.6723            0.2627\n3  AMZN            0.2070            0.1807\n2  GOOG            0.4728            0.1144\n8   XOM            0.1936            0.0225\n0  AAPL           -0.0951            0.0000\n1  MSFT           -0.9871            0.0000\n4  NVDA           -0.0356            0.0000\n5   JPM            0.0153            0.0000\n7    PG           -0.0814            0.0000\n\nMax Sharpe Ratio (Short Selling OK): 0.5787\nMax Sharpe Ratio (No Short Selling): 0.4957\n\n\nWe see that imposing the no short-selling constraint generally leads to different portfolio weights and a lower maximum Sharpe ratio, reflecting the trade-off between flexibility in asset allocation and risk-return optimization."
  },
  {
    "objectID": "stock-gbm.html",
    "href": "stock-gbm.html",
    "title": "Simulating Stock Price Path with GBM",
    "section": "",
    "text": "The Geometric Brownian Motion (GBM) model is widely used to model stock prices. It assumes that the stock price \\(S_t\\) follows the stochastic differential equation (SDE): \\[\ndS_t = \\mu S_t dt + \\sigma S_t dW_t,\n\\tag{1}\\]\nor, equivalently, \\[\n\\frac{dS_t}{S_t} = \\mu dt + \\sigma dW_t\n\\] where:\n\n\\(\\mu\\) is the drift coefficient: the expected rate of return of the stock (as \\(dS_t / S_t\\) can be viewed as the instantaneous return).\n\\(\\sigma\\) is the volatility coefficient: the standard deviation of returns.\n\\(W_t\\) is a standard Brownian motion (Wiener process).\n\nApplying Itô’s lemma, we can derive the process followed by the logarithm of the stock price: \\[\nd(\\ln S_t) = \\left(\\mu - \\frac{\\sigma^2}{2}\\right) dt + \\sigma dW_t.\n\\tag{2}\\]\nAs we will see in the next sections, we can simulate stock price paths using two different approaches based on these two equations."
  },
  {
    "objectID": "stock-gbm.html#recap-gbm-model-for-stock-prices",
    "href": "stock-gbm.html#recap-gbm-model-for-stock-prices",
    "title": "Simulating Stock Price Path with GBM",
    "section": "",
    "text": "The Geometric Brownian Motion (GBM) model is widely used to model stock prices. It assumes that the stock price \\(S_t\\) follows the stochastic differential equation (SDE): \\[\ndS_t = \\mu S_t dt + \\sigma S_t dW_t,\n\\tag{1}\\]\nor, equivalently, \\[\n\\frac{dS_t}{S_t} = \\mu dt + \\sigma dW_t\n\\] where:\n\n\\(\\mu\\) is the drift coefficient: the expected rate of return of the stock (as \\(dS_t / S_t\\) can be viewed as the instantaneous return).\n\\(\\sigma\\) is the volatility coefficient: the standard deviation of returns.\n\\(W_t\\) is a standard Brownian motion (Wiener process).\n\nApplying Itô’s lemma, we can derive the process followed by the logarithm of the stock price: \\[\nd(\\ln S_t) = \\left(\\mu - \\frac{\\sigma^2}{2}\\right) dt + \\sigma dW_t.\n\\tag{2}\\]\nAs we will see in the next sections, we can simulate stock price paths using two different approaches based on these two equations."
  },
  {
    "objectID": "stock-gbm.html#approach-1-direct-simulation-of-stock-prices",
    "href": "stock-gbm.html#approach-1-direct-simulation-of-stock-prices",
    "title": "Simulating Stock Price Path with GBM",
    "section": "Approach 1: Direct Simulation of Stock Prices",
    "text": "Approach 1: Direct Simulation of Stock Prices\nEquation 1 can be discretized over small time intervals \\(\\Delta t\\) as: \\[\nS_{t+\\Delta t} - S_t = \\mu S_t \\Delta t + \\sigma S_t \\epsilon \\sqrt{\\Delta t},\n\\] where \\(\\epsilon \\sim N(0,1)\\) is a standard normal random variable. The discretization replaces the infinitesimal change \\(dS_t\\) with a finite difference \\(S_{t+\\Delta t} - S_t\\), and \\(dW_t\\) with \\(\\epsilon \\sqrt{\\Delta t}\\).\nTwo points to note:\n\nThe term \\(\\epsilon \\sqrt{\\Delta t}\\) follows from the property of Brownian motion increments, which are normally distributed with mean 0 and variance \\(\\Delta t\\). This is true even the time interval \\(\\Delta t\\) is large.\nThis discretization is an approximation of price change over a short period of time \\(\\Delta t\\) because it assumes that \\(S_t\\) does not change significantly over the interval \\(\\Delta t\\).1 Therefore, the smaller the \\(\\Delta t\\), the more accurate the approximation.\n\n1 The SDE given by Equation 1 can be viewed as an Itô process\n\\[\ndx = a(x,t) dt + b(x,t) dW_t,\n\\]\nwhere both the expected drift rate and variance of \\(x\\) depend on the current value \\(x\\), and change over time. Our discretization assumes that over a small time interval \\(\\Delta t\\), the coefficients \\(a(x,t)\\) and \\(b(x,t)\\) remain approximately constant, allowing us to use their values at the beginning of the interval. This is known as the Euler-Maruyama method for numerically solving SDEs.This discretization leads us to simulate the stock price path by iteratively applying the above equation starting from an initial price \\(S_0\\).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Parameters\nS0 = 100  # Initial stock price\nmu = 0.05  # Drift coefficient\nsigma = 0.2  # Volatility coefficient\nT = 1.0  # Time horizon (1 year)\nN = 252  # Number of time steps (trading days in a year)\ndt = T / N  # Time step size\n\n# Generate all the standard normal shocks at once\nepsilon = np.random.normal(loc=0, scale=1, size=N)\n\n# Initialize the stock price array\n# We need N+1 points to include S0\nS = np.zeros(N+1)\n\n# set the initial stock price\nS[0] = S0\n\n# Simulate stock price path\nfor t in range(1, N+1):\n    S[t] = S[t-1] * (1 + mu * dt + sigma * epsilon[t-1] * np.sqrt(dt))\n\n# Plot the stock price path\nfig, ax = plt.subplots()\nax.plot(np.linspace(0, T, num=N+1), S)\nax.set_title('Simulated Stock Price Path using Direct Simulation of Prices')\nax.set_xlabel('Time (years)')\nax.set_ylabel('Stock Price')\nax.grid(axis='y', linestyle='--')\nplt.show()\n\n# Print the first and last 3 days of the simulated stock prices\nprint(\"First 3 days:\", S[:4]) # S[0] is the initial price\nprint(\"Last 3 days:\", S[-3:])\n\n\n\n\n\n\n\n\nFirst 3 days: [100.         100.64564228 100.49029032 101.33024055]\nLast 3 days: [102.38521068 100.77907013 101.96447248]"
  },
  {
    "objectID": "stock-gbm.html#approach-2-simulation-via-log-prices",
    "href": "stock-gbm.html#approach-2-simulation-via-log-prices",
    "title": "Simulating Stock Price Path with GBM",
    "section": "Approach 2: Simulation via Log-Prices",
    "text": "Approach 2: Simulation via Log-Prices\nWe can also simulate stock prices by first simulating the logarithm of stock prices using Equation 2, and then exponentiating to get the stock prices.\nThe SDE of \\(\\ln S_t\\) given by Equation 2 implies that for any time interval \\(\\Delta t\\),\n\\[\n\\ln S_{t+\\Delta t} - \\ln S_t = \\left(\\mu - \\frac{\\sigma^2}{2}\\right) \\Delta t + \\sigma \\epsilon \\sqrt{\\Delta t}.\n\\tag{3}\\]\nThis result does not involve any approximation as both the drift and variance terms of the \\(ln S_t\\) process are constant.2\n2 The SDE for \\(\\ln S_t\\) is a generalized Wiener process,\n\\[\ndx = a\\, dt + b\\, dW_t,\n\\]\nwhere both \\(a\\) and \\(b\\) are constants. This allows us to directly write down the distribution of increments over any time interval \\(\\Delta t\\) without approximation.3 Since equation Equation 3 holds for all \\(\\Delta t \\geq 0,\\) it’s tempting to simulate a stock price path with time interval \\(\\Delta t\\) by first constructing a sequence of \\(\\{\\epsilon \\sqrt{\\Delta t}, \\epsilon \\sqrt{2 \\Delta t}, ...\\}\\), where each \\(\\epsilon\\) is independently drawn from \\(N(0, 1)\\), and then using this sequence to build the log-price path. However, this approach is flawed because the increments of Brownian motion over overlapping intervals are not independent. For example, the increment \\(W_{2\\Delta t} - W_0\\) shares the same underlying Brownian motion as \\(W_{\\Delta t} - W_0\\). Therefore, we cannot simply generate independent normal variables for overlapping increments.We can simulate the log-price path by iteratively applying the above equation starting from an initial log-price \\(\\ln S_0\\). Once we have the log-prices, we can exponentiate them to get the stock prices.3\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Parameters\nS0 = 100  # Initial stock price\nmu = 0.05  # Drift coefficient\nsigma = 0.2  # Volatility coefficient\nT = 1.0  # Time horizon (1 year)\nN = 252  # Number of time steps (trading days in a year)\ndt = T / N  # Time step size\n\n# Generate all the standard normal shocks at once\nepsilon = np.random.normal(loc=0, scale=1, size=N)\n\n# Initialize the stock price and log stock price arrays\n# We need N+1 points to include S0\nS = np.zeros(N+1)\nlog_S = np.zeros(N+1)\n\n# Set the initial log stock price\nlog_S[0] = np.log(S0)\n\n# Simulate stock price path\nfor t in range(1, N+1):\n    log_S[t] = log_S[t-1] + (mu - 0.5 * sigma**2) * dt + sigma * epsilon[t-1] * np.sqrt(dt)\n\n# Exponentiate to get stock prices\nS = np.exp(log_S)\n\n# Plot the stock price path\nfig, ax = plt.subplots()\nax.plot(np.linspace(0, T, num=N+1), S)\nax.set_title('Simulated Stock Price Path using Log-Price Simulation')\nax.set_xlabel('Time (years)')\nax.set_ylabel('Stock Price')\nax.grid(axis='y', linestyle='--')\nplt.show()\n\n# Print the first and last 3 days of the simulated stock prices\nprint(\"First 3 days:\", S[:4]) # S[0] is the initial price\nprint(\"Last 3 days:\", S[-3:])\n\n\n\n\n\n\n\n\nFirst 3 days: [100.         100.63974344 100.47654577 101.31185987]\nLast 3 days: [102.23771695 100.63841696 101.82107276]\n\n\nNote that the stock price paths generated by both approaches are almost identical, as they are based on the same underlying GBM model and we have set the random seed for reproducibility. However, the log-price simulation is generally more accurate and stable, especially for larger time steps, because it avoids the approximation error inherent in the direct price simulation."
  },
  {
    "objectID": "stock-gbm.html#a-more-efficient-implementation",
    "href": "stock-gbm.html#a-more-efficient-implementation",
    "title": "Simulating Stock Price Path with GBM",
    "section": "A More Efficient Implementation",
    "text": "A More Efficient Implementation\nTaking the simulation via log-price approach, we can improve its efficiency by taking advantage of vectorized operations in NumPy. Instead of simulating each time step in a loop, we can calculate all time steps at once.\nTo do so, we first generate the Brownian motion path by cumulatively summing the scaled normal shocks (np.cumsum()). We then compute the log-prices using vectorized operations, and finally exponentiate to get the stock prices.\nLet’s write a function that implements this more efficient approach. In addition to the parameters used in the previous examples, the function takes another parameter specifying the number of paths to simulate. (We also include an optional random seed parameter for reproducibility.)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef simulate_gbm_path(S0, mu, sigma, T, N, num_path, seed=None):\n\n    if seed is not None:\n        np.random.seed(seed)\n    \n    dt = T / N # Time step size\n    t = np.linspace(0, T, N+1) # Time grid; N+1 points to include t=0\n\n    # Generate all the standard normal shocks at once for all paths\n    eps = np.random.normal(size=(num_path, N))\n    \n    # Generate the Brownian motion paths; add W(0) = 0\n    W = np.cumsum(np.sqrt(dt) * eps, axis=1)\n    W = np.concatenate((np.zeros((num_path, 1)), W), axis=1)\n\n    # Calculate log-prices using vectorized operations\n    log_S = np.log(S0) + (mu - 0.5 * sigma**2) * t + sigma * W\n\n    # Exponentiate to get stock prices\n    return np.exp(log_S)\n\n\nnp.sqrt(dt) * epsilon is an array of size (num_path, N). np.cumsum(, axis=1) cumulatively sum over all columns (axis=1) for each row of paths. This gives us the Brownian motion paths. (See here for more on np.cumsum().)\nconcatenates a column of zeros at the beginning of the Brownian motion paths to represent \\(W(0) = 0\\) for all paths. (See here for more on np.concatenate().)\n\nNow, let’s use this function to simulate and plot multiple stock price paths.\n\n# Parameters\nS0 = 100  # Initial stock price\nmu = 0.05  # Drift coefficient\nsigma = 0.2  # Volatility coefficient\nT = 1.0  # Time horizon (1 year)\nN = 252  # Number of time steps (trading days in a year)\nnum_path = 3  # Number of paths to simulate\n\n# Simulate stock price paths\nS = simulate_gbm_path(S0, mu, sigma, T, N, num_path, seed=42)\n\n# Plot the stock price path\nfig, ax = plt.subplots()\n\n# Plot each row as a separate line\nt = np.linspace(0, T, num=N+1)\nfor i in range(num_path):\n    ax.plot(t, S[i], label=f'Path {i+1}')\n\nax.set_title('Simulated Stock Price Path using Log-Price Simulation')\nax.set_xlabel('Time (years)')\nax.set_ylabel('Stock Price')\nax.grid(axis='y', linestyle='--')\nplt.legend()\nplt.show()\n\n# Print the first and last 3 days of the simulated stock prices for the first path\nprint(\"First 3 days of Path 1:\", S[0, :4]) # S[0,0] is the initial price\nprint(\"Last 3 days of Path 1:\", S[0, -3:])\n\n\n\n\n\n\n\n\nFirst 3 days of Path 1: [100.         100.63974344 100.47654577 101.31185987]\nLast 3 days of Path 1: [102.23771695 100.63841696 101.82107276]\n\n\nNote that the output for stock price path 1 is identical to those generated by the previous log-price simulation approach as both simulations are based on the exact same algorithm and we have set the random seed for reproducibility.\nThis implementation is more efficient because it leverages NumPy’s ability to perform operations on entire arrays at once, rather than iterating through each time step and path individually. This can lead to significant performance improvements, especially when simulating a large number of paths or time steps."
  },
  {
    "objectID": "stock-gbm.html#references",
    "href": "stock-gbm.html#references",
    "title": "Simulating Stock Price Path with GBM",
    "section": "References",
    "text": "References\nHull, J. C. (2021). Options, Futures, and Other Derivatives (11th ed.). Pearson."
  }
]